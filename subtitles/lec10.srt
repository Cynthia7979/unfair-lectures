1
00:00:00,000 --> 00:00:08,120
You yes

2
00:00:08,840 --> 00:00:24,320
Friday Friday

3
00:00:25,240 --> 00:00:28,400
Saturday

4
00:00:47,650 --> 00:00:50,630
What's up with the weather.

5
00:00:50,630 --> 00:00:54,369
I got here and I'm
basically drenching

6
00:00:54,369 --> 00:00:57,970
in this in whatever it is
that's happening outside.

7
00:00:57,970 --> 00:00:59,709
It's not really a rain,

8
00:00:59,709 --> 00:01:00,950
it's not really a fog.

9
00:01:00,950 --> 00:01:02,849
It's something that's
sort of precipitating

10
00:01:02,849 --> 00:01:05,125
as you walk through it, right?

11
00:01:05,125 --> 00:01:08,679
Okay, so we're done
with our VMM lectures,

12
00:01:08,679 --> 00:01:10,799
and today we're
planning to start

13
00:01:10,799 --> 00:01:14,340
our interrupts and
concurrency lecture sequence.

14
00:01:14,340 --> 00:01:17,260
So this is interrupts and
concurrency part one.

15
00:01:17,260 --> 00:01:19,920
I did want to do a bit of

16
00:01:19,920 --> 00:01:22,320
a wrap up on swapping
because we touched upon

17
00:01:22,320 --> 00:01:24,779
the virtual memory management
tips and tricks at

18
00:01:24,779 --> 00:01:27,679
the end of the last
lecture last week.

19
00:01:27,679 --> 00:01:29,499
And swapping was actually

20
00:01:29,499 --> 00:01:31,920
something that's fairly
important to talk about.

21
00:01:31,920 --> 00:01:32,940
Okay?

22
00:01:32,940 --> 00:01:36,600
So to get you guys warmed up,

23
00:01:36,600 --> 00:01:39,480
I'm sure all of you know
by now that lab two is

24
00:01:39,480 --> 00:01:42,684
due two weeks is
due on February 21.

25
00:01:42,684 --> 00:01:45,250
Uh, I don't know.

26
00:01:45,250 --> 00:01:46,969
It's one week from this Friday,

27
00:01:46,969 --> 00:01:48,350
not two weeks from this Friday.

28
00:01:48,350 --> 00:01:50,209
So it's due on February 21.

29
00:01:50,209 --> 00:01:51,930
I do recommend submitting you

30
00:01:51,930 --> 00:01:53,889
assignments towards
the end of this week,

31
00:01:53,889 --> 00:01:56,029
which is Valentine's Day.

32
00:01:56,029 --> 00:01:57,689
You know, what
better way to spend

33
00:01:57,689 --> 00:02:01,070
your Valentine's Day than
submit your lab, too, right?

34
00:02:01,070 --> 00:02:03,370
I'm sure many of
you will relate.

35
00:02:03,370 --> 00:02:07,180
Um, and.

36
00:02:08,140 --> 00:02:10,759
And the reason for this
is because it's going to

37
00:02:10,759 --> 00:02:12,659
take some time to debug, okay?

38
00:02:12,659 --> 00:02:14,460
So you may actually feel

39
00:02:14,460 --> 00:02:16,499
quite confident with
your algorithm.

40
00:02:16,499 --> 00:02:19,419
You may feel quite confident
with your grasp of

41
00:02:19,419 --> 00:02:21,119
the conceptual
stuff that sort of

42
00:02:21,119 --> 00:02:23,419
goes into figuring
things out in lab two.

43
00:02:23,419 --> 00:02:26,439
Many cases that you may
not have thought about,

44
00:02:26,439 --> 00:02:28,500
and this is quite normal.

45
00:02:28,500 --> 00:02:30,399
This is expected. That's what

46
00:02:30,399 --> 00:02:32,559
the test cases are there for.

47
00:02:32,559 --> 00:02:34,360
And do make sure that you leave

48
00:02:34,360 --> 00:02:37,239
a week to go through
them because it's

49
00:02:37,239 --> 00:02:39,259
highly unlikely that
you'll get all of

50
00:02:39,259 --> 00:02:42,439
your 100% of your score,

51
00:02:42,439 --> 00:02:44,759
you know, the first time

52
00:02:44,759 --> 00:02:47,279
you submit or even the
second time you submit.

53
00:02:47,279 --> 00:02:50,360
Okay? I mentioned
declaring teams.

54
00:02:50,360 --> 00:02:51,740
This is the boring stuff.

55
00:02:51,740 --> 00:02:54,899
I just want to make
it official, right?

56
00:02:54,899 --> 00:02:57,080
And I want to get
through it fast.

57
00:02:57,080 --> 00:03:00,819
So bear with me. There were
still 22 students unassigned,

58
00:03:00,819 --> 00:03:03,419
and so just sort of
declaratively specifying that

59
00:03:03,419 --> 00:03:04,839
those teams are going to

60
00:03:04,839 --> 00:03:06,919
be treated as single
student group.

61
00:03:06,919 --> 00:03:09,360
So at the start of the lecture,

62
00:03:09,360 --> 00:03:11,060
I checked, there's some students

63
00:03:11,060 --> 00:03:12,779
that were not assigned
to any group.

64
00:03:12,779 --> 00:03:16,000
That means that you're
in a group by yourself.

65
00:03:16,000 --> 00:03:18,860
Okay? Welcome. Join.

66
00:03:18,860 --> 00:03:22,720
Okay. And grade
scope, furthermore,

67
00:03:22,720 --> 00:03:24,140
I've been told by the TA

68
00:03:24,140 --> 00:03:25,619
that grade scope
is going to throw

69
00:03:25,619 --> 00:03:28,819
an error if the team
member is not specified.

70
00:03:28,819 --> 00:03:31,100
So make sure that you do
specify a team member

71
00:03:31,100 --> 00:03:33,480
on every single
decision to ensure

72
00:03:33,480 --> 00:03:35,720
appropriate accounting
for the number

73
00:03:35,720 --> 00:03:39,740
of the times you have
submitted as a team.

74
00:03:39,740 --> 00:03:42,800
Any questions so far?

75
00:03:45,940 --> 00:03:51,279
Okay. Now, here's a slightly
more interesting slide.

76
00:03:51,279 --> 00:03:53,619
Okay, so first of all,

77
00:03:53,619 --> 00:03:56,399
we have identified
a handful of people

78
00:03:56,399 --> 00:04:01,079
who perhaps accidentally
left their code public.

79
00:04:01,079 --> 00:04:03,019
And I just want to, again,

80
00:04:03,019 --> 00:04:06,439
as a matter of politic clarity
was specified that this

81
00:04:06,439 --> 00:04:07,959
puts these people in

82
00:04:07,959 --> 00:04:11,199
the gray area of
academic dishonesty.

83
00:04:11,199 --> 00:04:16,809
Um, most cases are just
simple and honest mistakes.

84
00:04:16,809 --> 00:04:19,509
And so this slide
is to disambiguate

85
00:04:19,509 --> 00:04:22,830
how you should collaborate on

86
00:04:22,830 --> 00:04:25,810
your Github repositories
in a private fashion

87
00:04:25,810 --> 00:04:27,009
that doesn't get you into

88
00:04:27,009 --> 00:04:29,190
the gray area of
academic dishonesty.

89
00:04:29,190 --> 00:04:30,910
Make sure you initialize

90
00:04:30,910 --> 00:04:33,250
the private repository that

91
00:04:33,250 --> 00:04:36,440
is only visible to
you and your partner.

92
00:04:36,440 --> 00:04:38,910
Then you perform
a local clone of

93
00:04:38,910 --> 00:04:41,090
the XV six public
repository that we

94
00:04:41,090 --> 00:04:44,670
provided to you as the
teaching staff of CS 3210.

95
00:04:44,670 --> 00:04:47,050
You check out the branch. Okay.

96
00:04:47,050 --> 00:04:50,210
Then remote you add a remote

97
00:04:50,210 --> 00:04:52,530
for the private repository

98
00:04:52,530 --> 00:04:54,229
that you have just
created, okay?

99
00:04:54,229 --> 00:04:55,370
And there's a command for that.

100
00:04:55,370 --> 00:04:58,389
Git remote ad that
adds a remote.

101
00:04:58,389 --> 00:05:00,570
Then just verify that

102
00:05:00,570 --> 00:05:02,929
your private repository
has been added

103
00:05:02,929 --> 00:05:04,550
and is now listed as one of

104
00:05:04,550 --> 00:05:07,289
the remotes for your
local repository,

105
00:05:07,289 --> 00:05:09,249
X V six repository,

106
00:05:09,249 --> 00:05:13,789
and you do that with Git
remote V. And finally push.

107
00:05:13,789 --> 00:05:16,430
To your private remote.

108
00:05:16,430 --> 00:05:18,150
I'm calling it lab two, private.

109
00:05:18,150 --> 00:05:19,589
It's your private remote.

110
00:05:19,589 --> 00:05:22,330
The branch name lab two.

111
00:05:22,330 --> 00:05:24,770
Any questions about that?

112
00:05:27,320 --> 00:05:30,420
How many of you are
unaware that if you

113
00:05:30,420 --> 00:05:34,159
fork a public repository,
it stays public.

114
00:05:34,320 --> 00:05:37,120
People were unaware.

115
00:05:37,120 --> 00:05:40,200
Okay, so now you're aware.

116
00:05:40,200 --> 00:05:43,219
We are going to be actively
looking for these cases.

117
00:05:43,219 --> 00:05:45,439
Please do not make this mistake.

118
00:05:45,439 --> 00:05:47,980
And this is sort of
a recipe for you

119
00:05:47,980 --> 00:05:50,319
to avoid this
situation altogether.

120
00:05:50,319 --> 00:05:52,199
Any questions?

121
00:05:54,920 --> 00:05:59,160
Okay. Quick question for you.

122
00:05:59,160 --> 00:06:03,200
How many of you actually
covered disk swapping in 2,200?

123
00:06:03,200 --> 00:06:05,500
Is that most of you?

124
00:06:05,500 --> 00:06:07,219
The majority of you covered

125
00:06:07,219 --> 00:06:10,100
the disk swapping
algorithm, 2,200, right?

126
00:06:10,100 --> 00:06:12,760
And so are you familiar
with the concept of

127
00:06:12,760 --> 00:06:15,000
pushing a physical frame
to the disk, you know,

128
00:06:15,000 --> 00:06:16,480
setting the appropriate bits in

129
00:06:16,480 --> 00:06:19,720
the page table entry to
reflect that, right?

130
00:06:19,720 --> 00:06:24,790
You're comfortable
with this? Sort of.

131
00:06:24,790 --> 00:06:26,490
How far back was it?

132
00:06:26,490 --> 00:06:27,850
Was it like last semester?

133
00:06:27,850 --> 00:06:30,370
Was it a year ago,
two years ago?

134
00:06:30,370 --> 00:06:33,950
So that means long time ago.

135
00:06:33,950 --> 00:06:35,870
Okay. Okay, good. Thank you.

136
00:06:35,870 --> 00:06:38,539
Yeah, I like that
kind of feedback.

137
00:06:38,539 --> 00:06:40,990
So again, as I mentioned a few

138
00:06:40,990 --> 00:06:43,650
times over the course of
this semester is that

139
00:06:43,650 --> 00:06:44,950
sometimes we'll be coming back

140
00:06:44,950 --> 00:06:46,430
to the algorithms
that are sort of

141
00:06:46,430 --> 00:06:49,530
very familiar to you from
prior semesters, right?

142
00:06:49,530 --> 00:06:51,110
But then we'll sort of start

143
00:06:51,110 --> 00:06:52,909
asking philosophical
questions about it.

144
00:06:52,909 --> 00:06:54,990
Like, why does this
happen the way it does?

145
00:06:54,990 --> 00:06:56,970
You know, what sort of is

146
00:06:56,970 --> 00:06:58,630
there a way to
conceptualize this?

147
00:06:58,630 --> 00:07:00,589
You know, now that you've
learned some skills,

148
00:07:00,589 --> 00:07:02,469
you actually have a
pretty heavy sort of

149
00:07:02,469 --> 00:07:04,550
toolbox hanging
off to your side,

150
00:07:04,550 --> 00:07:06,049
you know, attached
to your jeans.

151
00:07:06,049 --> 00:07:08,529
And now you start asking
questions about tools.

152
00:07:08,529 --> 00:07:11,190
Well, why should I use
this tool over that one?

153
00:07:11,190 --> 00:07:12,550
And why is this tool shaped

154
00:07:12,550 --> 00:07:13,990
this particular fashion, right?

155
00:07:13,990 --> 00:07:15,690
And so let's try to do

156
00:07:15,690 --> 00:07:18,649
that for the disc swapping
algorithm as well.

157
00:07:18,649 --> 00:07:21,370
So let's see.

158
00:07:21,370 --> 00:07:24,130
What's a good way to
start this? Oh, yeah.

159
00:07:24,130 --> 00:07:26,810
And in the context
of this algorithm,

160
00:07:26,810 --> 00:07:29,169
what's called the
clock algorithm,

161
00:07:29,169 --> 00:07:30,870
we're also going to sort

162
00:07:30,870 --> 00:07:32,990
of talk about those
two different things.

163
00:07:32,990 --> 00:07:35,450
What are the mechanisms
that sort of enable

164
00:07:35,450 --> 00:07:39,109
the clock algorithm to even
happen to be feasible,

165
00:07:39,109 --> 00:07:40,650
to be possible, right?

166
00:07:40,650 --> 00:07:43,650
And once you have this
set of mechanisms,

167
00:07:43,650 --> 00:07:45,630
they're sort of your
hammers, right?

168
00:07:45,630 --> 00:07:47,130
And then the question is, how do

169
00:07:47,130 --> 00:07:49,330
you apply these mechanisms?

170
00:07:49,330 --> 00:07:50,910
How do you enact a policy

171
00:07:50,910 --> 00:07:53,200
is sort of an
orthogonal question.

172
00:07:53,200 --> 00:07:55,769
Um because there's
a whole sequence,

173
00:07:55,769 --> 00:07:57,330
a whole set of policies that you

174
00:07:57,330 --> 00:07:59,949
can support and enable

175
00:07:59,949 --> 00:08:01,870
with a set of mechanisms
that you provide.

176
00:08:01,870 --> 00:08:05,130
So I will do my best sort
of in the context of

177
00:08:05,130 --> 00:08:07,289
multiple places in this
course to actually

178
00:08:07,289 --> 00:08:08,409
bring this to your attention

179
00:08:08,409 --> 00:08:09,589
that there's this separation.

180
00:08:09,589 --> 00:08:12,190
And that's fairly
important if you actually

181
00:08:12,190 --> 00:08:13,930
decide to proceed with

182
00:08:13,930 --> 00:08:16,454
doing systems research
in the future.

183
00:08:16,454 --> 00:08:20,640
Okay. So let's see.

184
00:08:20,640 --> 00:08:22,580
So one of, of course,

185
00:08:22,580 --> 00:08:26,480
policy questions here, and
that's a policy question is,

186
00:08:26,480 --> 00:08:28,960
how do we choose which
pages to evict, right?

187
00:08:28,960 --> 00:08:31,219
You have a whole bunch
of physical frames.

188
00:08:31,219 --> 00:08:33,340
These physical frames
are being occupied.

189
00:08:33,340 --> 00:08:35,900
They're currently, you
know, holding some content,

190
00:08:35,900 --> 00:08:38,200
and you need to
make up make space.

191
00:08:38,200 --> 00:08:39,479
You know, what do you do? So one

192
00:08:39,479 --> 00:08:41,059
of those frames needs to go.

193
00:08:41,059 --> 00:08:42,919
What's the best way for us to

194
00:08:42,919 --> 00:08:47,639
decide kind of which
page needs to go?

195
00:08:47,639 --> 00:08:49,480
And we're going to discuss

196
00:08:49,480 --> 00:08:52,119
sort of the best case and the
worst case of this, right?

197
00:08:52,119 --> 00:08:53,460
I'm sure if well,

198
00:08:53,460 --> 00:08:54,759
let me ask this as a question.

199
00:08:54,759 --> 00:09:01,040
Which page do we need to
evict? How do you decide?

200
00:09:01,040 --> 00:09:04,579
You've taken this
algorithm before, yes.

201
00:09:05,380 --> 00:09:13,999
Fist What's Ahead
of the free list.

202
00:09:13,999 --> 00:09:17,819
Okay. Anybody else? Yeah, yeah,

203
00:09:17,819 --> 00:09:19,160
so it's something basically

204
00:09:19,160 --> 00:09:21,039
by associative
thinking, you know,

205
00:09:21,039 --> 00:09:23,179
almost like a large
language model, you know,

206
00:09:23,179 --> 00:09:25,459
it sort of maps with a
very high probability

207
00:09:25,459 --> 00:09:27,959
to this least recently
used keyword, right?

208
00:09:27,959 --> 00:09:30,300
So you must have learned
at least recently used,

209
00:09:30,300 --> 00:09:31,600
it's sort of a really
good heuristic

210
00:09:31,600 --> 00:09:32,939
for you to deal
with that, right?

211
00:09:32,939 --> 00:09:34,479
But then, you know, is it

212
00:09:34,479 --> 00:09:37,199
the best possible policy, right?

213
00:09:37,199 --> 00:09:40,020
And how far away from the
best possible policy?

214
00:09:40,020 --> 00:09:42,320
What is the complexity
of this policy?

215
00:09:42,320 --> 00:09:43,699
What are the overheads,

216
00:09:43,699 --> 00:09:46,300
the memory overhead
associated with this policy?

217
00:09:46,300 --> 00:09:49,539
The time compute overhead
associated with this policy.

218
00:09:49,539 --> 00:09:53,209
Does anybody know Yeah,

219
00:09:53,209 --> 00:09:55,549
so let's see if we can
get through this, right?

220
00:09:55,549 --> 00:09:58,589
And of course, before we
get started with that,

221
00:09:58,589 --> 00:10:01,230
just a reminder
from the last week

222
00:10:01,230 --> 00:10:04,970
is our physical memory
limited by our RAM?

223
00:10:07,090 --> 00:10:10,689
Well, it's not, right?

224
00:10:11,530 --> 00:10:15,169
Because we talked about
oversubscription,

225
00:10:15,169 --> 00:10:17,369
and we talked about the
ability to allocate

226
00:10:17,369 --> 00:10:19,750
a lot more virtual memory
than physical memory.

227
00:10:19,750 --> 00:10:22,650
And we also talked about
having the ability to map

228
00:10:22,650 --> 00:10:27,629
other things into memory
than just your DRAM, right?

229
00:10:27,629 --> 00:10:30,609
Files are very good
example of that, right?

230
00:10:30,609 --> 00:10:32,789
So you can actually
have a portion of

231
00:10:32,789 --> 00:10:36,730
your virtual memory where
you're mapping files.

232
00:10:36,730 --> 00:10:38,349
And those files don't have

233
00:10:38,349 --> 00:10:40,589
any physical frames
associated with that,

234
00:10:40,589 --> 00:10:42,949
or do not necessarily have to

235
00:10:42,949 --> 00:10:46,109
have physical frames
associated with that, right?

236
00:10:46,109 --> 00:10:49,869
So the concept of swapping
is when you have to

237
00:10:49,869 --> 00:10:51,750
save memory to disk

238
00:10:51,750 --> 00:10:54,409
when we round out of
physical frames of memory.

239
00:10:54,409 --> 00:10:56,030
So in other words,
you're basically

240
00:10:56,030 --> 00:10:57,829
picking and choosing some tiles,

241
00:10:57,829 --> 00:10:59,330
so to speak, behind

242
00:10:59,330 --> 00:11:02,735
this memory mapped file
and swap them to disc.

243
00:11:02,735 --> 00:11:05,000
In order to make space
for somebody else

244
00:11:05,000 --> 00:11:07,880
who needs physical
frames right now.

245
00:11:07,880 --> 00:11:11,400
And memory mapping is another
example, as I mentioned,

246
00:11:11,400 --> 00:11:13,080
where we map file information

247
00:11:13,080 --> 00:11:14,820
into the virtual address space,

248
00:11:14,820 --> 00:11:17,419
and we basically anytime we

249
00:11:17,419 --> 00:11:20,700
perform an IO
operation on sorry,

250
00:11:20,700 --> 00:11:22,839
a memory read or write on

251
00:11:22,839 --> 00:11:26,880
the virtual addresses to
which the file was mapped,

252
00:11:26,880 --> 00:11:29,779
then these memory reads
and writes are going to

253
00:11:29,779 --> 00:11:33,240
translate into writes
back to the file, okay?

254
00:11:33,240 --> 00:11:34,880
They're not going
to translate into

255
00:11:34,880 --> 00:11:37,080
writes to the physical
frames of memory,

256
00:11:37,080 --> 00:11:40,060
they will translate
into file IO.

257
00:11:40,060 --> 00:11:50,569
Make sense? Okay.

258
00:11:50,569 --> 00:11:54,489
So how do we choose which
pages to evict to disc, right?

259
00:11:54,489 --> 00:11:56,549
We're facing this necessity.

260
00:11:56,549 --> 00:11:58,850
We need to make this decision.

261
00:11:58,890 --> 00:12:02,189
Well, what is the ideal
page to evict to this?

262
00:12:02,189 --> 00:12:05,370
So let's start thinking
about best case scenario.

263
00:12:05,370 --> 00:12:08,450
If you sort of have
infinite resources

264
00:12:08,450 --> 00:12:10,490
or you have infinite
amount of knowledge,

265
00:12:10,490 --> 00:12:12,349
you know, would you proceed with

266
00:12:12,349 --> 00:12:15,969
randomly choosing
physical frames to evict?

267
00:12:15,969 --> 00:12:19,650
You know, would you like to
do it in a random fashion?

268
00:12:21,320 --> 00:12:24,519
No, why not?

269
00:12:25,160 --> 00:12:28,080
So if I were to
ask you literally,

270
00:12:28,080 --> 00:12:31,200
I'm going to give you a
random eviction policy.

271
00:12:31,200 --> 00:12:35,440
Like, how do you know
it's a bad design choice?

272
00:12:36,600 --> 00:12:38,639
Yeah.

273
00:12:48,480 --> 00:12:51,540
Yeah, exactly. So
there's actually

274
00:12:51,540 --> 00:12:54,189
a an application is

275
00:12:54,189 --> 00:12:57,449
accessing memory in a
specific pattern, right?

276
00:12:57,449 --> 00:12:59,550
And there's a lot

277
00:12:59,550 --> 00:13:01,589
of papers out there that
even try to learn what

278
00:13:01,589 --> 00:13:03,170
this pattern is and even train

279
00:13:03,170 --> 00:13:05,030
machine learning models in order

280
00:13:05,030 --> 00:13:07,409
to identify the optimal
page eviction algorithm,

281
00:13:07,409 --> 00:13:09,050
even use reinforcement learning

282
00:13:09,050 --> 00:13:10,589
to come up with the policies for

283
00:13:10,589 --> 00:13:14,449
page eviction as a function
of the memory access pattern.

284
00:13:14,449 --> 00:13:16,969
The keyword here, all of
that is advanced stuff,

285
00:13:16,969 --> 00:13:18,329
but the keyword here is

286
00:13:18,329 --> 00:13:21,250
apparently memory
access pattern matters.

287
00:13:21,250 --> 00:13:23,869
Thank you, right? Memory
access pattern matters.

288
00:13:23,869 --> 00:13:26,589
So, great. Now that
we've established that,

289
00:13:26,589 --> 00:13:29,349
you know, what sort
of an optimal space?

290
00:13:29,349 --> 00:13:31,289
What sort of an
optimal scenario?

291
00:13:31,289 --> 00:13:34,529
The best case, case is
that we actually know.

292
00:13:34,529 --> 00:13:36,329
You have oracular knowledge of

293
00:13:36,329 --> 00:13:38,589
what that access
pattern is, right?

294
00:13:38,589 --> 00:13:41,170
And once you know
that, and you're

295
00:13:41,170 --> 00:13:44,250
faced with the necessity
to evict a page,

296
00:13:44,250 --> 00:13:48,129
which page would you evict
at a specific point in time?

297
00:13:48,190 --> 00:13:52,409
Yeah. Is the longest
period of time.

298
00:13:52,409 --> 00:13:54,889
Exactly. Basically,
you would have

299
00:13:54,889 --> 00:13:55,970
the regular knowledge of

300
00:13:55,970 --> 00:13:58,269
which pages are going
to be accessed, right?

301
00:13:58,269 --> 00:14:00,270
And then given this information,

302
00:14:00,270 --> 00:14:02,849
you will pick the page with

303
00:14:02,849 --> 00:14:06,190
the least probability of
access in the near future,

304
00:14:06,190 --> 00:14:07,790
which is the one that's furthest

305
00:14:07,790 --> 00:14:10,870
away, there's actually a name.

306
00:14:10,870 --> 00:14:12,569
It's actually an algorithm,

307
00:14:12,569 --> 00:14:14,430
and there's a name
for this algorithm.

308
00:14:14,430 --> 00:14:16,230
For anyone from
computer architecture,

309
00:14:16,230 --> 00:14:19,089
you may recognize this as it?

310
00:14:19,089 --> 00:14:21,379
At is algorithm, right?

311
00:14:21,379 --> 00:14:24,449
So ultimately, and
the key here is

312
00:14:24,449 --> 00:14:27,310
that you want to think
about trying to evict

313
00:14:27,310 --> 00:14:29,430
pages that will be least useful

314
00:14:29,430 --> 00:14:33,049
or the way to conceptualize
this is sort of

315
00:14:33,049 --> 00:14:36,130
associating some sort of
utility with the page

316
00:14:36,130 --> 00:14:37,469
and trying to evict

317
00:14:37,469 --> 00:14:39,649
pages with the smallest
amount of utility.

318
00:14:39,649 --> 00:14:42,309
And everything else sort of
becomes a detail, right?

319
00:14:42,309 --> 00:14:43,710
Becomes a policy choice.

320
00:14:43,710 --> 00:14:44,889
Well, how do we know

321
00:14:44,889 --> 00:14:47,509
which pages are more
or less useful, right?

322
00:14:47,509 --> 00:14:49,530
Well, one way to say
is that it's furthest

323
00:14:49,530 --> 00:14:51,650
away from us if we
have that information.

324
00:14:51,650 --> 00:14:53,550
Another way to tell is that, oh,

325
00:14:53,550 --> 00:14:55,050
maybe it's the least
recently used,

326
00:14:55,050 --> 00:14:57,949
and that becomes a
probabilistic decision, right?

327
00:14:57,949 --> 00:15:00,110
It becomes a
probabilistic decision.

328
00:15:00,110 --> 00:15:02,749
In this particular case,
though, it's Belts algorithm.

329
00:15:02,749 --> 00:15:04,149
So, of course, we don't

330
00:15:04,149 --> 00:15:06,289
know what the axis
pattern is going to be.

331
00:15:06,289 --> 00:15:09,129
So what's commonly used is

332
00:15:09,129 --> 00:15:11,310
the least recently
used approximation

333
00:15:11,310 --> 00:15:14,529
or a heuristic in order
to approximate this,

334
00:15:14,529 --> 00:15:17,909
in order to sort of
with high probability,

335
00:15:17,909 --> 00:15:20,190
identify the physical frames

336
00:15:20,190 --> 00:15:22,930
that are going to
be least useful.

337
00:15:23,030 --> 00:15:26,489
But for those of you who
are thinkers, you know,

338
00:15:26,489 --> 00:15:29,829
the second I said,
least useful, you know,

339
00:15:29,829 --> 00:15:31,549
you can think of all sorts of

340
00:15:31,549 --> 00:15:33,609
other ways to reason

341
00:15:33,609 --> 00:15:36,110
about the utility of
using a particular frame,

342
00:15:36,110 --> 00:15:37,869
like the arithmetic intensity or

343
00:15:37,869 --> 00:15:40,030
the extent to which that
frame is going to be used.

344
00:15:40,030 --> 00:15:41,469
Are we going to do only a

345
00:15:41,469 --> 00:15:43,050
single read or
write to that page?

346
00:15:43,050 --> 00:15:44,789
Is it a read or write, right?

347
00:15:44,789 --> 00:15:48,449
Or are we going to hammer
it 1,000 times, right?

348
00:15:48,449 --> 00:15:50,849
So that can also feed utility,

349
00:15:50,849 --> 00:15:52,809
and you can all of a
sudden come up with a sort

350
00:15:52,809 --> 00:15:56,810
of a very exponential
policy design space,

351
00:15:56,810 --> 00:15:58,450
which makes it interesting.

352
00:15:58,450 --> 00:16:00,709
But I don't want
to digress there.

353
00:16:00,940 --> 00:16:04,299
Now, least recently used, fine.

354
00:16:04,299 --> 00:16:06,780
Let's talk about
least recently used.

355
00:16:06,780 --> 00:16:09,879
It's very expensive
to track, right?

356
00:16:09,879 --> 00:16:12,500
So what do you
need in principle,

357
00:16:12,500 --> 00:16:15,099
in order to be

358
00:16:15,099 --> 00:16:17,659
able to enact the least
recently used policy?

359
00:16:17,659 --> 00:16:20,539
What do we need
for that? What is

360
00:16:20,539 --> 00:16:23,859
the necessary condition and
the information you need?

361
00:16:26,420 --> 00:16:30,019
Yeah. The ordering
of the pages and

362
00:16:30,019 --> 00:16:33,390
when they were access
like when they were used.

363
00:16:33,390 --> 00:16:35,319
The ordering of
the pages, right.

364
00:16:35,319 --> 00:16:36,780
So actually,

365
00:16:36,780 --> 00:16:39,020
that's interesting that
you mentioned ordering.

366
00:16:39,020 --> 00:16:40,520
Usually people say something

367
00:16:40,520 --> 00:16:41,919
that's closely related to that,

368
00:16:41,919 --> 00:16:44,479
but it's actually
semantically different.

369
00:16:44,479 --> 00:16:47,479
Let's make it a little
bit more simple.

370
00:16:47,479 --> 00:16:50,599
You probably want to know
the timestamp, right?

371
00:16:50,599 --> 00:16:52,059
You want to know when it was

372
00:16:52,059 --> 00:16:53,379
accessed in order to be

373
00:16:53,379 --> 00:16:54,940
able to give you
this information.

374
00:16:54,940 --> 00:16:57,400
But it's strictly more
expressive than the ordering.

375
00:16:57,400 --> 00:16:58,520
And that's the
difference between

376
00:16:58,520 --> 00:17:01,680
cardinal and ordinal ordering

377
00:17:01,680 --> 00:17:03,540
because cardinal carries
more information.

378
00:17:03,540 --> 00:17:06,079
But anyway, that's a nuance.

379
00:17:06,079 --> 00:17:08,404
So ordering is actually
what you want.

380
00:17:08,404 --> 00:17:12,650
But how do you even for
the purposes of order,

381
00:17:12,650 --> 00:17:15,510
though, or timestamp,
it doesn't matter.

382
00:17:15,510 --> 00:17:17,490
You need to somehow capture

383
00:17:17,490 --> 00:17:20,029
this information on
every single access,

384
00:17:20,029 --> 00:17:22,169
read or write, right?

385
00:17:22,169 --> 00:17:24,109
So what's the problem with that?

386
00:17:24,109 --> 00:17:26,170
Are we feeling good
about capturing

387
00:17:26,170 --> 00:17:29,610
this information on every
single read or write?

388
00:17:36,890 --> 00:17:41,729
So I once had a project
and it was a project on

389
00:17:41,729 --> 00:17:44,969
a Mince CPU that

390
00:17:44,969 --> 00:17:48,449
consisted of an eight by eight
mesh interconnect, right?

391
00:17:48,449 --> 00:17:50,349
And I was hacking on the kernel,

392
00:17:50,349 --> 00:17:52,069
and what I wanted it had

393
00:17:52,069 --> 00:17:54,430
four memory controllers
along the perimeter,

394
00:17:54,430 --> 00:17:55,949
and I wanted to figure out

395
00:17:55,949 --> 00:17:58,310
what's the optimal
placement of a thread.

396
00:17:58,310 --> 00:18:00,890
And the way I wanted to
figure this out is basically

397
00:18:00,890 --> 00:18:02,209
which memory controller is

398
00:18:02,209 --> 00:18:03,749
drawing its physical
frames from.

399
00:18:03,749 --> 00:18:06,830
Where what is it
accessing in some sense?

400
00:18:06,830 --> 00:18:08,089
And the reason for this is

401
00:18:08,089 --> 00:18:09,370
because the way it was accessing

402
00:18:09,370 --> 00:18:13,149
memory is actually by traversing
this mesh interconnect.

403
00:18:13,149 --> 00:18:15,849
And so what mattered is
the Euclidean distance.

404
00:18:15,849 --> 00:18:19,499
Sorry, is the
Manhattan distance.

405
00:18:19,499 --> 00:18:22,070
Okay. And so, of course,

406
00:18:22,070 --> 00:18:24,469
the first thing that comes
to mind is I started

407
00:18:24,469 --> 00:18:27,530
trapping every single access
to the memory controller,

408
00:18:27,530 --> 00:18:29,809
and it was not

409
00:18:29,809 --> 00:18:32,049
a very performance system
as a result of that,

410
00:18:32,049 --> 00:18:34,189
but it gave me the statistics.

411
00:18:34,189 --> 00:18:37,049
So is that what we want to do?

412
00:18:37,410 --> 00:18:40,010
Gave me the algorithm.

413
00:18:40,010 --> 00:18:42,509
I published that paper,

414
00:18:42,509 --> 00:18:45,735
but the system was unusable.

415
00:18:45,735 --> 00:18:50,299
Why? Come on, guys. Yeah.

416
00:18:50,299 --> 00:18:52,239
Yeah, too much overhead, right?

417
00:18:52,239 --> 00:18:54,079
Like every single time,

418
00:18:54,079 --> 00:18:57,360
even on a read, you actually
have to perform a write.

419
00:18:57,360 --> 00:18:59,059
So every single access,

420
00:18:59,059 --> 00:19:00,860
including reads,
turns into a write.

421
00:19:00,860 --> 00:19:03,700
A write of the
metadata to capture,

422
00:19:03,700 --> 00:19:06,059
this timestamp or ordering

423
00:19:06,059 --> 00:19:08,020
information or a virtual
clock information,

424
00:19:08,020 --> 00:19:09,720
right? That's super expensive.

425
00:19:09,720 --> 00:19:12,579
We don't want to pay
that cost, right?

426
00:19:14,660 --> 00:19:18,259
So what do we do instead, right?

427
00:19:18,259 --> 00:19:19,779
Well, instead, we have to come

428
00:19:19,779 --> 00:19:21,600
up with a different mechanism.

429
00:19:21,600 --> 00:19:23,939
So here's an example.
Let's say we

430
00:19:23,939 --> 00:19:26,039
have four frames of
memory top to bottom.

431
00:19:26,039 --> 00:19:28,459
So the four different
color rectangles

432
00:19:28,459 --> 00:19:31,339
are actually physical
frames of memory, okay?

433
00:19:31,339 --> 00:19:35,919
And, and the number

434
00:19:35,919 --> 00:19:37,859
written inside the rectangle is

435
00:19:37,859 --> 00:19:40,300
actually essentially
the timestamp,

436
00:19:40,300 --> 00:19:45,660
right, or the timestamp when
that page was last accessed.

437
00:19:45,660 --> 00:19:47,019
So we have four physical

438
00:19:47,019 --> 00:19:48,820
frames that were
already touched.

439
00:19:48,820 --> 00:19:51,159
So we have one,
two, three, four,

440
00:19:51,159 --> 00:19:52,859
and we have a current

441
00:19:52,859 --> 00:19:54,919
access counter that's
standing at five.

442
00:19:54,919 --> 00:19:56,319
You know, we can
think of it as a

443
00:19:56,319 --> 00:19:58,319
virtual lampard clock, right.

444
00:19:58,319 --> 00:20:00,239
And now we are sort of

445
00:20:00,239 --> 00:20:02,259
accessing this page
right here and notice

446
00:20:02,259 --> 00:20:07,559
how its access counter was
updated 3-5. Did you see that?

447
00:20:07,559 --> 00:20:10,480
Okay, so we are updating it 3-5.

448
00:20:10,480 --> 00:20:13,660
And we advanced the
access counter to six.

449
00:20:13,660 --> 00:20:17,500
Okay, now we are
accessing the top frame,

450
00:20:17,500 --> 00:20:20,639
and so we're going to update
its access counter or

451
00:20:20,639 --> 00:20:24,479
timestamp point it was
accessed 2-6, right?

452
00:20:24,479 --> 00:20:26,979
And the global access counter

453
00:20:26,979 --> 00:20:28,580
is going to advance to seven.

454
00:20:28,580 --> 00:20:30,079
And now the time comes to

455
00:20:30,079 --> 00:20:31,939
evict and we know
exactly what to do.

456
00:20:31,939 --> 00:20:34,159
We are going to evict

457
00:20:34,159 --> 00:20:37,980
the least recently accessed
page in this particular case,

458
00:20:37,980 --> 00:20:40,479
page with the access
counter one, right?

459
00:20:40,479 --> 00:20:43,839
Pretty straightforward.
But as we mentioned,

460
00:20:43,839 --> 00:20:45,399
there's a significant amount of

461
00:20:45,399 --> 00:20:48,020
overhead to actually keep
track of this information.

462
00:20:48,020 --> 00:20:50,155
And so, um

463
00:20:50,155 --> 00:20:53,489
So basically doing this is
going to be a very bad thing.

464
00:20:53,489 --> 00:20:55,409
The system becomes,
strictly speaking,

465
00:20:55,409 --> 00:20:57,450
unusable. Can we do better?

466
00:20:57,450 --> 00:21:00,569
You know, can we actually
think of the properties of

467
00:21:00,569 --> 00:21:03,049
the least recently used
algorithm and come up

468
00:21:03,049 --> 00:21:04,769
with a heuristic that

469
00:21:04,769 --> 00:21:06,530
actually has much
better performance?

470
00:21:06,530 --> 00:21:09,509
Because what's the worst
case performance here?

471
00:21:12,530 --> 00:21:15,369
Paying for every
single access, right?

472
00:21:15,369 --> 00:21:17,450
So basically your trap Well,

473
00:21:17,450 --> 00:21:19,609
the worst case performance
here is with respect

474
00:21:19,609 --> 00:21:21,610
to how many expensive operations

475
00:21:21,610 --> 00:21:22,849
you need to perform, right?

476
00:21:22,849 --> 00:21:25,470
I need to specify that.
And that is a trap.

477
00:21:25,470 --> 00:21:27,170
How many traps are we paying

478
00:21:27,170 --> 00:21:29,009
for actually enacting
this policy?

479
00:21:29,009 --> 00:21:33,029
We are paying one
trap per axis, right?

480
00:21:33,029 --> 00:21:35,429
You guys with me?
Okay, the question

481
00:21:35,429 --> 00:21:37,329
is can we do it better, right?

482
00:21:37,329 --> 00:21:39,869
You can improve the
algorithmic complexity.

483
00:21:39,869 --> 00:21:41,209
Actually, the data structure

484
00:21:41,209 --> 00:21:42,529
complexity that keeps track of

485
00:21:42,529 --> 00:21:45,729
that from AN to
log end to A one,

486
00:21:45,729 --> 00:21:49,309
but the overhead of actual
traps is not going to go away.

487
00:21:49,309 --> 00:21:53,289
And that's a problem. So
instead, let's do this.

488
00:21:53,289 --> 00:21:56,769
Let's try to approximate LRU

489
00:21:56,769 --> 00:21:59,389
by essentially arranging
our physical frames

490
00:21:59,389 --> 00:22:00,829
into a circular buffer.

491
00:22:00,829 --> 00:22:04,190
So now our physical
frames are in a circle,

492
00:22:04,190 --> 00:22:06,049
a clockwise circle, right?

493
00:22:06,049 --> 00:22:07,509
And the numbers inside

494
00:22:07,509 --> 00:22:10,770
those things actually
correspond to the frame number.

495
00:22:10,770 --> 00:22:13,969
So let's see if I
get a pointer here.

496
00:22:19,660 --> 00:22:21,699
Okay.

497
00:22:24,300 --> 00:22:27,319
All right. So basically,
this is frame number one,

498
00:22:27,319 --> 00:22:28,599
this is frame two, this is

499
00:22:28,599 --> 00:22:30,040
frame three, this is frame four.

500
00:22:30,040 --> 00:22:33,280
And we're going to have
sort of an axis bit

501
00:22:33,280 --> 00:22:35,399
that will be sort of arbitrarily

502
00:22:35,399 --> 00:22:37,539
set for each of those frames,

503
00:22:37,539 --> 00:22:39,585
either to one or zero.

504
00:22:39,585 --> 00:22:43,970
And this algorithm sort

505
00:22:43,970 --> 00:22:45,669
of comes to life at

506
00:22:45,669 --> 00:22:47,630
the time when we need
to perform an eviction.

507
00:22:47,630 --> 00:22:49,970
So that means that we
need to frame five here,

508
00:22:49,970 --> 00:22:53,149
and we need to place
it in lieu of one of

509
00:22:53,149 --> 00:22:54,469
those four that you currently

510
00:22:54,469 --> 00:22:56,849
see in the circular
buffer, okay?

511
00:22:56,849 --> 00:22:58,629
So how do we do that?

512
00:22:58,629 --> 00:23:01,269
Well, we start with
a pointer somewhere.

513
00:23:01,269 --> 00:23:03,650
Now, the pointer, the
big arrow right here,

514
00:23:03,650 --> 00:23:07,070
the big arrow is essentially
a version of our clock.

515
00:23:07,070 --> 00:23:09,350
And as we rotate the arrow,

516
00:23:09,350 --> 00:23:11,249
this is analogous to

517
00:23:11,249 --> 00:23:15,469
monotonically increasing
the Lamport clock, okay?

518
00:23:15,469 --> 00:23:17,870
Now, what are we doing
with the axis bit?

519
00:23:17,870 --> 00:23:19,789
So we're checking
the current vertex

520
00:23:19,789 --> 00:23:21,249
where the arrow is pointing,

521
00:23:21,249 --> 00:23:23,549
and if A equals to one,

522
00:23:23,549 --> 00:23:26,130
basically, we don't
touch that vertex.

523
00:23:26,130 --> 00:23:28,170
We set A to zero,

524
00:23:28,170 --> 00:23:30,089
and we proceed to point to

525
00:23:30,089 --> 00:23:33,414
the next vertex in
the circular buffer.

526
00:23:33,414 --> 00:23:35,260
In this particular case,

527
00:23:35,260 --> 00:23:37,520
the axis bit is set to zero,

528
00:23:37,520 --> 00:23:41,300
and that is going to
allow us to replace

529
00:23:41,300 --> 00:23:45,839
two with the frame five and
evict frame number two.

530
00:23:45,839 --> 00:23:48,499
And we're going to
set the axis bit to

531
00:23:48,499 --> 00:23:52,119
one because remember that
this algorithm is actually

532
00:23:52,119 --> 00:23:55,259
on acess to frame five that we

533
00:23:55,259 --> 00:23:56,820
needed to swap in in order

534
00:23:56,820 --> 00:23:58,660
to complete that
access operation.

535
00:23:58,660 --> 00:24:00,220
And so by the time we are done,

536
00:24:00,220 --> 00:24:03,429
we want our axis bit set to one.

537
00:24:03,429 --> 00:24:07,559
Makes sense? Okay, so we've
completed the eviction.

538
00:24:07,559 --> 00:24:11,080
We now evicted two,
and we replaced five.

539
00:24:11,080 --> 00:24:13,139
And at this point
in time, you know,

540
00:24:13,139 --> 00:24:15,119
it doesn't really
matter if we advance

541
00:24:15,119 --> 00:24:17,419
the clock or we don't
advance the clock because we

542
00:24:17,419 --> 00:24:19,899
know that the very beginning
of this algorithm is

543
00:24:19,899 --> 00:24:23,859
checking for the axis
being one or zero, right?

544
00:24:23,860 --> 00:24:26,900
So did that make sense?

545
00:24:27,380 --> 00:24:34,539
Are you sure? No. Okay.

546
00:24:34,900 --> 00:24:37,979
Do you have any questions?

547
00:24:42,990 --> 00:24:45,449
So one question you might have

548
00:24:45,449 --> 00:24:47,570
is how to make sure
that our access bit

549
00:24:47,570 --> 00:24:49,310
is set to one when
we read a page

550
00:24:49,310 --> 00:24:51,529
or write a page? Because
that's what we want.

551
00:24:51,529 --> 00:24:54,989
Remember that the problem
we've identified is

552
00:24:54,989 --> 00:24:56,389
that we pay too much

553
00:24:56,389 --> 00:24:58,529
overhead on every single
access to memory.

554
00:24:58,529 --> 00:25:00,049
We trap on every single access

555
00:25:00,049 --> 00:25:01,489
to memory in the previous kind

556
00:25:01,489 --> 00:25:03,870
of let's call it
naive implementation

557
00:25:03,870 --> 00:25:05,309
of the algorithm, right?

558
00:25:05,309 --> 00:25:07,449
In this algorithm, we
want to avoid that,

559
00:25:07,449 --> 00:25:10,109
and we'll avoid
that if a read or

560
00:25:10,109 --> 00:25:13,209
write is hitting a frame
with axis bit set to one.

561
00:25:13,209 --> 00:25:15,090
So when that happens,

562
00:25:15,090 --> 00:25:16,450
no trap takes place,

563
00:25:16,450 --> 00:25:20,629
and the read or write operation
actually proceeds, okay?

564
00:25:20,629 --> 00:25:22,789
So that's the way
to think about it.

565
00:25:22,789 --> 00:25:24,149
So what we want to

566
00:25:24,149 --> 00:25:27,189
accomplish is the common
case being simple,

567
00:25:27,189 --> 00:25:29,210
the common case
being performant.

568
00:25:29,210 --> 00:25:30,869
And the common case here is

569
00:25:30,869 --> 00:25:34,089
basically when the axis
bit is set to one,

570
00:25:34,089 --> 00:25:37,049
the page is sort of
frequently being used,

571
00:25:37,049 --> 00:25:40,430
and it hasn't been
reset to zero,

572
00:25:40,430 --> 00:25:43,190
back to zero by the
clock algorithm.

573
00:25:44,540 --> 00:25:47,540
So given this clock algorithm,

574
00:25:47,540 --> 00:25:49,659
the question then becomes,

575
00:25:49,659 --> 00:25:52,280
precisely when do we trap?

576
00:25:52,280 --> 00:25:54,439
And what's the
mechanism for us to

577
00:25:54,439 --> 00:25:56,940
actually enable this
trap to make this trap

578
00:25:56,940 --> 00:25:59,840
happen that actually resets

579
00:25:59,840 --> 00:26:03,980
the clock resets it
from one back to zero.

580
00:26:03,980 --> 00:26:05,639
When do I need to be

581
00:26:05,639 --> 00:26:08,700
notified that a process
has access to page?

582
00:26:08,700 --> 00:26:11,719
Right. We need to make sure
that we think through this,

583
00:26:11,719 --> 00:26:13,599
like, is it every
single read or right?

584
00:26:13,599 --> 00:26:15,859
That's the first thing to
get out of your way, right?

585
00:26:15,859 --> 00:26:19,299
We've already established that
the answer to this is no.

586
00:26:21,350 --> 00:26:23,929
And so we could
think about it from

587
00:26:23,929 --> 00:26:27,269
the perspective of the
finite state automaton.

588
00:26:27,269 --> 00:26:30,849
Basically, our aces bit can
be in two possible states.

589
00:26:30,849 --> 00:26:35,229
Either it's in state zero or
it's in state one, right?

590
00:26:36,630 --> 00:26:39,450
Okay, so now that we established

591
00:26:39,450 --> 00:26:43,649
those two states in which
the access bit can be,

592
00:26:43,649 --> 00:26:46,370
let's decompose
this step by step.

593
00:26:46,370 --> 00:26:48,489
When the axis bit
is already set to

594
00:26:48,489 --> 00:26:52,430
one on a read and write,
do we need to do anything?

595
00:26:53,750 --> 00:26:57,209
The axis bit is
set to one, right?

596
00:26:57,209 --> 00:26:59,229
The read or write can proceed.

597
00:26:59,229 --> 00:27:01,709
This is essentially
this edge right here.

598
00:27:01,709 --> 00:27:07,230
This is the state
transition edge 1-1.

599
00:27:07,510 --> 00:27:09,949
So no trap should happen here.

600
00:27:09,949 --> 00:27:12,689
Everybody agrees with
me. So axis bit is

601
00:27:12,689 --> 00:27:16,209
one reading or writing
is going to stay one.

602
00:27:16,209 --> 00:27:19,209
So that's the transition
edge to itself.

603
00:27:19,209 --> 00:27:22,729
Okay? Now, there are two more
kind of transitions here.

604
00:27:22,729 --> 00:27:25,989
What are those two more
transitions that are interesting?

605
00:27:26,580 --> 00:27:31,539
State transition edges in
this two vertex graph.

606
00:27:31,539 --> 00:27:33,039
Anyone? Yes.

607
00:27:33,039 --> 00:27:35,059
One to zero and zero to one.

608
00:27:35,059 --> 00:27:38,699
Yeah, 1-0 and 0-1, right?

609
00:27:38,699 --> 00:27:45,320
Okay. And so let's talk
about one to zero.

610
00:27:45,320 --> 00:27:48,219
So one to zero, when
does that happen?

611
00:27:48,219 --> 00:27:50,879
It's this one right here.
I've just animated it.

612
00:27:50,879 --> 00:27:53,819
This state transition 1-0.
When does that happen?

613
00:27:53,819 --> 00:27:57,939
We saw it on the
previous slide. Yeah.

614
00:27:57,939 --> 00:28:01,279
Yeah, it happens inside
the algorithm which

615
00:28:01,279 --> 00:28:04,614
is running in your trap
handler already, right?

616
00:28:04,614 --> 00:28:06,989
And so clearly, that's not

617
00:28:06,989 --> 00:28:10,290
our mechanism to force

618
00:28:10,290 --> 00:28:11,529
the trap to happen because

619
00:28:11,529 --> 00:28:13,229
we're already inside
the trap handler.

620
00:28:13,229 --> 00:28:15,089
So something else
must have caused it,

621
00:28:15,089 --> 00:28:16,749
right? Well, what is it?

622
00:28:16,749 --> 00:28:18,670
Well, the only
possible explanation

623
00:28:18,670 --> 00:28:20,670
is this transition right here,

624
00:28:20,670 --> 00:28:25,129
basically, the transition
from state zero to state one.

625
00:28:25,129 --> 00:28:29,490
So that means that anytime
the axis bit is zero,

626
00:28:29,490 --> 00:28:33,889
we want to design an algorithm
that sort of shadows

627
00:28:33,889 --> 00:28:36,089
the axis bit zero and

628
00:28:36,089 --> 00:28:39,910
forces our paging system
to give us a trap.

629
00:28:39,910 --> 00:28:44,690
So that we get the opportunity
to set this axis bid

630
00:28:44,690 --> 00:28:46,530
back to one and complete

631
00:28:46,530 --> 00:28:50,129
the zero to one
state transition.

632
00:28:52,170 --> 00:28:55,189
I don't know about you, but
I find this really exciting.

633
00:28:55,189 --> 00:28:59,050
I sort of it really explains
what happens under the hood.

634
00:28:59,050 --> 00:29:00,649
It explains precisely how to

635
00:29:00,649 --> 00:29:03,929
design these mechanisms
that actually give you

636
00:29:03,929 --> 00:29:06,429
the ability to interpose
on control flow

637
00:29:06,429 --> 00:29:08,149
so that you can
actually implement

638
00:29:08,149 --> 00:29:09,944
these mechanisms yourself.

639
00:29:09,944 --> 00:29:12,780
Okay. And I just
walked you through

640
00:29:12,780 --> 00:29:15,599
this thought process from

641
00:29:15,599 --> 00:29:18,680
first principles
from ground zero,

642
00:29:18,680 --> 00:29:21,179
how to come up with
this understanding

643
00:29:21,179 --> 00:29:22,759
of what it means for us to

644
00:29:22,759 --> 00:29:24,860
design this mechanism
to give us a trap.

645
00:29:24,860 --> 00:29:26,520
Well, so what we've established

646
00:29:26,520 --> 00:29:28,179
so far is that we need to have

647
00:29:28,179 --> 00:29:31,920
a mechanism that gives a trap
on a state transition 0-1.

648
00:29:31,920 --> 00:29:33,359
So what does that imply?

649
00:29:33,359 --> 00:29:36,460
That implies and what are
our mechanismic bits?

650
00:29:36,460 --> 00:29:38,839
We just have some
bits to deal with.

651
00:29:38,839 --> 00:29:40,560
In this particular case,

652
00:29:40,560 --> 00:29:43,039
we can use the present
bit and we can

653
00:29:43,039 --> 00:29:45,840
make it shadow the
axis bit, okay?

654
00:29:45,840 --> 00:29:48,120
Because the axis bit
is the logical bit.

655
00:29:48,120 --> 00:29:51,979
But in order for us to enact
the physical permissions,

656
00:29:51,979 --> 00:29:54,559
as we discussed during
the last lecture,

657
00:29:54,559 --> 00:29:57,139
we need to use one of those bits

658
00:29:57,139 --> 00:29:59,359
in the page table
entry itself, right?

659
00:29:59,359 --> 00:30:03,119
So let's use the present
bit or PTE underscore P

660
00:30:03,119 --> 00:30:05,559
to sort of shadow whatever

661
00:30:05,559 --> 00:30:08,319
the axis bit is
currently set to.

662
00:30:08,319 --> 00:30:11,400
So that means that if
the axis bit is zero,

663
00:30:11,400 --> 00:30:13,720
we want to set the PTEP to zero.

664
00:30:13,720 --> 00:30:16,300
And of course, if PTP is zero,

665
00:30:16,300 --> 00:30:19,279
when we try to access the
frame that it's pointing to,

666
00:30:19,279 --> 00:30:23,449
we're going to get
a trap, right?

667
00:30:23,449 --> 00:30:26,169
So that's the mechanism
that we've just designed.

668
00:30:26,169 --> 00:30:28,309
We can use PTEP to

669
00:30:28,309 --> 00:30:31,849
shadow or whatever the
state of the axis bit is.

670
00:30:31,849 --> 00:30:33,270
If it's zero, we set it to zero,

671
00:30:33,270 --> 00:30:35,389
if it's one, we set
it to one, right?

672
00:30:35,389 --> 00:30:39,170
And upon setting PTP to zero,

673
00:30:39,170 --> 00:30:40,689
we're going to basically

674
00:30:40,689 --> 00:30:42,750
get into the situation
where we're getting

675
00:30:42,750 --> 00:30:44,469
a trap that gives
us the opportunity

676
00:30:44,469 --> 00:30:47,190
to complete the state
transition 0-1.

677
00:30:47,190 --> 00:30:49,990
By the clock algorithm.

678
00:30:54,360 --> 00:30:58,300
Okay. And our invariant
here is, again,

679
00:30:58,300 --> 00:31:01,019
by the time we are done
with the read right,

680
00:31:01,019 --> 00:31:02,859
we want the axis bit to be one,

681
00:31:02,859 --> 00:31:05,659
and we've accomplished that
with this mechanism as well.

682
00:31:05,659 --> 00:31:07,139
It's sort of a
necessary condition

683
00:31:07,139 --> 00:31:09,299
check mark that we need to have.

684
00:31:09,299 --> 00:31:12,780
And it must be true for
this LRU approximation,

685
00:31:12,780 --> 00:31:17,759
heuristic to work.
Okay. Let's see.

686
00:31:17,759 --> 00:31:20,619
So here's a quick
complexity question.

687
00:31:20,619 --> 00:31:22,599
Now, what have we done with

688
00:31:22,599 --> 00:31:25,140
the worst case performance
of this clock algorithm?

689
00:31:25,140 --> 00:31:26,479
So it used to be that we were

690
00:31:26,479 --> 00:31:28,099
trapping on every single axis.

691
00:31:28,099 --> 00:31:30,160
Now, what's the worst case?

692
00:31:30,160 --> 00:31:32,500
How frequently can
we possibly trap?

693
00:31:32,500 --> 00:31:34,879
And let's go back to
this so that you have

694
00:31:34,879 --> 00:31:36,919
a visualization
that can help you

695
00:31:36,919 --> 00:31:40,160
understand the worst case
performance of this algorithm.

696
00:31:40,160 --> 00:31:43,740
And it's with respect with
the most expensive operation,

697
00:31:43,740 --> 00:31:45,620
which is taking a trap.

698
00:31:45,620 --> 00:31:49,049
Anyone? Yes. We're only chopping

699
00:31:49,049 --> 00:31:52,610
when we get to evic
instead of every.

700
00:31:52,610 --> 00:31:56,749
But let's say kind of a
little bit, you're right,

701
00:31:56,749 --> 00:31:59,609
but a little bit more formally
kind of with respect to

702
00:31:59,609 --> 00:32:01,569
either a number of axises or

703
00:32:01,569 --> 00:32:03,709
the number of frames or
something like that.

704
00:32:03,709 --> 00:32:05,289
It's order one.

705
00:32:05,289 --> 00:32:08,789
It's sort of order N.
It's order something.

706
00:32:13,230 --> 00:32:17,850
Oh, sorry, I didn't
see you, yeah. Zero.

707
00:32:17,850 --> 00:32:20,549
Yeah, yeah. So is there
a possibility for

708
00:32:20,549 --> 00:32:24,030
them all to be zero?
Is it possible?

709
00:32:25,860 --> 00:32:28,280
I guess it would
be very unlikely,

710
00:32:28,280 --> 00:32:30,979
but maybe potentially possible.

711
00:32:30,979 --> 00:32:33,599
I guess you have to have
at least one or two frames

712
00:32:33,599 --> 00:32:35,599
in memory, right?

713
00:32:35,599 --> 00:32:37,679
Yeah, so it is, in
fact, possible,

714
00:32:37,679 --> 00:32:39,820
and in the absolute worst case,

715
00:32:39,820 --> 00:32:41,619
your clock algorithm is going to

716
00:32:41,619 --> 00:32:43,979
cycle through the
entire buffer, right?

717
00:32:43,979 --> 00:32:47,380
And so in this particular case,

718
00:32:47,380 --> 00:32:49,059
the worst case is
that you're going

719
00:32:49,059 --> 00:32:50,859
to be taking a trap on

720
00:32:50,859 --> 00:32:52,879
every physical frame for

721
00:32:52,879 --> 00:32:55,239
which the axis bit is
set to zero, right?

722
00:32:55,239 --> 00:32:58,225
Because remember, our PTP
is shadowing aces bit.

723
00:32:58,225 --> 00:33:02,229
And this is significantly
better than dealing with

724
00:33:02,229 --> 00:33:04,289
the worst case that
we discussed for

725
00:33:04,289 --> 00:33:05,769
the naive implementation where

726
00:33:05,769 --> 00:33:08,909
it's every single
read or write, okay?

727
00:33:09,710 --> 00:33:17,590
Okay. Um, yeah, I'm not
sure why I have it again.

728
00:33:17,590 --> 00:33:20,049
So basically, I
think I demonstrated

729
00:33:20,049 --> 00:33:21,449
here how the worst
case can happen.

730
00:33:21,449 --> 00:33:23,489
Yeah, there we go.
Here's an illustration

731
00:33:23,489 --> 00:33:25,209
of how the worst
case can happen.

732
00:33:25,209 --> 00:33:27,090
So this is the initial state,

733
00:33:27,090 --> 00:33:29,389
and it is possible, sort of as

734
00:33:29,389 --> 00:33:32,109
a function of the
memory access patterns,

735
00:33:32,109 --> 00:33:34,069
as you pointed out, right,

736
00:33:34,069 --> 00:33:40,049
that our application is sort
of very memory intensive.

737
00:33:40,049 --> 00:33:41,769
You know, it has
actually, you know,

738
00:33:41,769 --> 00:33:45,409
performed a walk through all of

739
00:33:45,409 --> 00:33:46,929
its physical frames or

740
00:33:46,929 --> 00:33:48,550
the virtual memory that's

741
00:33:48,550 --> 00:33:51,189
allocated to that
address, right?

742
00:33:51,189 --> 00:33:53,899
And so all of our access
bits are set to one.

743
00:33:53,899 --> 00:33:56,489
This is the worst possible
case that can happen, right?

744
00:33:56,489 --> 00:33:58,510
And so now we start
looking for that page.

745
00:33:58,510 --> 00:34:01,449
You know, we've run out of
memory. So this is set to one.

746
00:34:01,449 --> 00:34:04,169
We must advance the clock.
This is set to one.

747
00:34:04,169 --> 00:34:05,970
We set it to zero
advance the clock.

748
00:34:05,970 --> 00:34:08,149
This is set to one, we set it
to zero advance the clock.

749
00:34:08,149 --> 00:34:10,069
This is set to one. We set it
to zero advance the clock.

750
00:34:10,069 --> 00:34:12,009
We're back to the beginning
and now we can evict.

751
00:34:12,009 --> 00:34:14,329
So that's the worst
possible case.

752
00:34:14,329 --> 00:34:17,529
Okay? So that just
animates this,

753
00:34:17,529 --> 00:34:19,409
and then we finally
perform the eviction.

754
00:34:19,409 --> 00:34:21,289
We put the physical frame

755
00:34:21,289 --> 00:34:23,749
five instead of one
right here, right?

756
00:34:23,749 --> 00:34:26,629
And we set the axis bit to one.

757
00:34:34,350 --> 00:34:37,609
Right. And so one
additional thing

758
00:34:37,609 --> 00:34:39,890
to mention here and it's
a little bit nuanced.

759
00:34:39,890 --> 00:34:43,110
I'm going to try to sort of
go through this quickly.

760
00:34:43,110 --> 00:34:46,909
This will only happen on
eviction. That's number one.

761
00:34:46,909 --> 00:34:48,529
And number two, it's also

762
00:34:48,529 --> 00:34:50,890
a combination of both
the memory pressure,

763
00:34:50,890 --> 00:34:53,970
right, and the memory access
pattern of the application.

764
00:34:53,970 --> 00:34:55,390
So if you were to actually

765
00:34:55,390 --> 00:34:57,369
take the conditional
probability,

766
00:34:57,369 --> 00:35:00,370
something like this is
highly unlikely to happen.

767
00:35:00,370 --> 00:35:02,309
In other words,
it's unlikely for

768
00:35:02,309 --> 00:35:04,849
all frames to actually
be marked as accessed in

769
00:35:04,849 --> 00:35:07,409
the beginning and you being

770
00:35:07,409 --> 00:35:11,129
in the eviction situation
at that point in time.

771
00:35:11,129 --> 00:35:15,890
Okay. And so this seems like
a very worthwhile heuristic.

772
00:35:15,890 --> 00:35:18,089
It seems like it
performs quite well.

773
00:35:18,089 --> 00:35:22,680
So how do we choose
which pages to evict?

774
00:35:22,680 --> 00:35:24,480
We've discussed the
clock algorithm.

775
00:35:24,480 --> 00:35:26,399
We put pages in a circular list,

776
00:35:26,399 --> 00:35:27,820
we mark them as access.

777
00:35:27,820 --> 00:35:30,379
We have this logical access bit.

778
00:35:30,380 --> 00:35:33,880
Anytime it's being
accessed, read or written.

779
00:35:33,880 --> 00:35:36,880
And on evict the clock
iterates pages in the queue.

780
00:35:36,880 --> 00:35:39,399
So our pointer is

781
00:35:39,399 --> 00:35:43,099
essentially our monotonically
increasing virtual clock.

782
00:35:43,099 --> 00:35:45,180
And if the page is accessed,

783
00:35:45,180 --> 00:35:46,419
we mark it clean or

784
00:35:46,419 --> 00:35:51,259
unaccessed by setting
the access bit to zero.

785
00:35:51,259 --> 00:35:53,890
And if the page is
unaccessed we evict.

786
00:35:53,890 --> 00:35:57,060
So that's sort of the
rundown or the summary

787
00:35:57,060 --> 00:36:00,139
of the algorithm that we
just came to learn about.

788
00:36:00,139 --> 00:36:03,040
Any questions about
the algorithm?

789
00:36:10,570 --> 00:36:14,469
Okay, so let's talk
about concurrency.

790
00:36:14,469 --> 00:36:16,789
The first question
to start with is,

791
00:36:16,789 --> 00:36:19,709
you know, or interrupts
and concurrency, right?

792
00:36:19,709 --> 00:36:22,390
How do we handle
unexpected events?

793
00:36:22,390 --> 00:36:24,129
How do I get notified that

794
00:36:24,129 --> 00:36:26,390
something new just
happened in my system?

795
00:36:26,390 --> 00:36:30,949
Because remember that in our
on Neumann architecture,

796
00:36:30,949 --> 00:36:34,049
you sort of have a flow
of instructions, right?

797
00:36:34,049 --> 00:36:38,190
And if nothing happens,
nothing unexpected happens,

798
00:36:38,190 --> 00:36:39,930
that flow of instruction

799
00:36:39,930 --> 00:36:43,149
can just proceed as
scheduled, right?

800
00:36:43,149 --> 00:36:46,769
And so what could
possibly happen that

801
00:36:46,769 --> 00:36:51,049
actually interrupts those
that flow of instructions?

802
00:36:56,050 --> 00:36:58,589
One example is
right there, right?

803
00:36:58,589 --> 00:37:03,049
You start interacting keyboard
with keyboard, right?

804
00:37:03,049 --> 00:37:04,990
You start getting
network packets.

805
00:37:04,990 --> 00:37:07,130
Those are unexpected
events that cannot

806
00:37:07,130 --> 00:37:10,089
be programmatically expected
by your program, right?

807
00:37:10,089 --> 00:37:11,869
The fact that a
network arrived is

808
00:37:11,869 --> 00:37:14,669
sort of completely unexpected
asynchronous event,

809
00:37:14,669 --> 00:37:18,050
and you need to have mechanisms
to handle those events.

810
00:37:18,050 --> 00:37:19,830
What is that mechanism?

811
00:37:19,830 --> 00:37:23,029
The only way we have to deal
with something like that,

812
00:37:23,029 --> 00:37:25,170
something that we didn't expect

813
00:37:25,170 --> 00:37:27,185
is the interrupt mechanism.

814
00:37:27,185 --> 00:37:28,679
Okay?

815
00:37:32,800 --> 00:37:36,719
Now, what types of things
do we need interrupts for?

816
00:37:36,719 --> 00:37:39,739
You know, what are some
of the use cases, right?

817
00:37:39,739 --> 00:37:43,139
We already talked about
a couple of them, right?

818
00:37:43,139 --> 00:37:44,940
We talked about
keyboard interrupts.

819
00:37:44,940 --> 00:37:46,479
We talked about network data.

820
00:37:46,479 --> 00:37:47,839
So I'm just going
to go through this

821
00:37:47,839 --> 00:37:49,559
really quickly and then

822
00:37:49,559 --> 00:37:51,119
we'll try to sort of categorize

823
00:37:51,119 --> 00:37:53,020
this into a taxonomy, okay?

824
00:37:53,020 --> 00:37:55,000
And so we've already
talked about paging,

825
00:37:55,000 --> 00:37:57,359
in order for paging
mechanism to Would

826
00:37:57,359 --> 00:38:00,760
paging mechanism work if
we didn't have interrupts?

827
00:38:01,400 --> 00:38:04,959
Would it work? Can
we make it work?

828
00:38:08,050 --> 00:38:10,169
No, right? We've been

829
00:38:10,169 --> 00:38:11,909
talking about these
traps, you know,

830
00:38:11,909 --> 00:38:14,489
as a mechanism for us to
actually interpose on

831
00:38:14,489 --> 00:38:16,170
the control flow of
the application.

832
00:38:16,170 --> 00:38:17,869
It would not work, right?

833
00:38:17,869 --> 00:38:20,829
And so we are actually
depending on this mechanism of

834
00:38:20,829 --> 00:38:21,989
exceptions in order to

835
00:38:21,989 --> 00:38:23,630
implement the entire
paging system.

836
00:38:23,630 --> 00:38:25,009
So interrupts are actually so

837
00:38:25,009 --> 00:38:26,989
fundamental to everything we've

838
00:38:26,989 --> 00:38:28,689
been talking about
up to this point.

839
00:38:28,689 --> 00:38:30,330
As a matter of fact,
would scheduling

840
00:38:30,330 --> 00:38:32,090
work if we didn't
have interrupts?

841
00:38:32,090 --> 00:38:35,029
Are you even able to
switch between processes?

842
00:38:35,029 --> 00:38:36,419
Right?

843
00:38:36,419 --> 00:38:39,229
So we're talking about
timer interrupts, right?

844
00:38:39,229 --> 00:38:40,830
And those are
hardware interrupts.

845
00:38:40,830 --> 00:38:42,589
What happens if you have

846
00:38:42,589 --> 00:38:46,210
a buffer overflow actually on
one of your device buffers?

847
00:38:46,210 --> 00:38:48,030
If we didn't have interrupts,

848
00:38:48,030 --> 00:38:49,809
would we be able to sort

849
00:38:49,809 --> 00:38:51,869
of even assure the
correctness of

850
00:38:51,869 --> 00:38:55,209
the applications that don't

851
00:38:55,209 --> 00:38:58,969
give us an interrupt on
buffer overflows, right?

852
00:38:58,969 --> 00:39:02,510
Debugging, right? When you're
interacting with the GDB,

853
00:39:02,510 --> 00:39:04,490
you set a breakpoint somewhere,

854
00:39:04,490 --> 00:39:07,229
and I don't know if you sort
of realize this or not,

855
00:39:07,229 --> 00:39:09,050
but the reason why
the program actually

856
00:39:09,050 --> 00:39:12,749
stops where you set
a breakpoint has

857
00:39:12,749 --> 00:39:20,080
something to do with
receiving an interrupt, okay?

858
00:39:20,080 --> 00:39:21,560
And so even though interrupts

859
00:39:21,560 --> 00:39:23,120
may seem boring on the surface,

860
00:39:23,120 --> 00:39:24,999
like, oh, it's just
an interrupt, right?

861
00:39:24,999 --> 00:39:28,339
They're actually very,
very fundamental

862
00:39:28,339 --> 00:39:30,159
mechanismic things that you

863
00:39:30,159 --> 00:39:33,460
absolutely have to have in
the design of your system.

864
00:39:33,460 --> 00:39:36,680
Communication and
interprocess interrupts.

865
00:39:36,680 --> 00:39:40,099
In order for process A
to talk to process B,

866
00:39:40,099 --> 00:39:42,040
you can send it interrupt

867
00:39:42,040 --> 00:39:43,799
and actually deliver
a message that way.

868
00:39:43,799 --> 00:39:46,060
Like in some sense,

869
00:39:46,060 --> 00:39:48,759
you can think of sort of
the old school USPS, right,

870
00:39:48,759 --> 00:39:52,465
where you raise a flag
when the mail arrived,

871
00:39:52,465 --> 00:39:54,489
and I'm not even
going to mention

872
00:39:54,489 --> 00:39:57,989
AOL because that's
even before my time.

873
00:39:58,110 --> 00:40:01,489
But it had a similar kind of

874
00:40:01,489 --> 00:40:03,549
icon where the mail

875
00:40:03,549 --> 00:40:05,889
arrives and your red
flag goes up, right?

876
00:40:05,889 --> 00:40:07,770
It's sort of an interrupt,

877
00:40:07,770 --> 00:40:09,989
which serves as a
notification that

878
00:40:09,989 --> 00:40:13,810
an unexpected asynchronous event

879
00:40:13,810 --> 00:40:16,810
has occurred that
demands your attention.

880
00:40:16,810 --> 00:40:19,049
And actually, that's
precisely captured, right?

881
00:40:19,049 --> 00:40:22,310
An interrupt is an unexpected
asynchronous event

882
00:40:22,310 --> 00:40:24,960
that occurred demands
your attention.

883
00:40:24,960 --> 00:40:29,029
That's sort of almost by
definition what an interrupt is.

884
00:40:29,029 --> 00:40:30,630
And it also gives us ability

885
00:40:30,630 --> 00:40:32,330
to implement control features

886
00:40:32,330 --> 00:40:37,009
like setting up watchdogs
in our system, right?

887
00:40:37,009 --> 00:40:40,429
And to handle
catastrophic scenarios.

888
00:40:40,429 --> 00:40:44,309
Like, for example, if, you
know, we're all human,

889
00:40:44,309 --> 00:40:47,049
we make mistakes, even if
we are kernel developers,

890
00:40:47,049 --> 00:40:49,929
we can make mistakes
in the kernel, right?

891
00:40:50,260 --> 00:40:53,179
And when we make
mistakes in the kernel,

892
00:40:53,179 --> 00:40:56,039
the kernel can get
into very, very,

893
00:40:56,039 --> 00:40:58,059
very weird states
that are very, very,

894
00:40:58,059 --> 00:41:00,839
very hard to debug, very
hard to get out of.

895
00:41:00,839 --> 00:41:02,739
I'm sure some of you

896
00:41:02,739 --> 00:41:04,679
may have noticed
that already, right?

897
00:41:04,679 --> 00:41:06,519
If not, you absolutely will,

898
00:41:06,519 --> 00:41:08,799
by the time you
get to Lab three,

899
00:41:08,799 --> 00:41:12,340
which is all about
interrupts and concurrence.

900
00:41:12,830 --> 00:41:15,290
And so you need to
have interrupts

901
00:41:15,290 --> 00:41:16,789
that actually get you
out of that state.

902
00:41:16,789 --> 00:41:18,870
And those are the non
maskable interrupts,

903
00:41:18,870 --> 00:41:20,649
like basically pressing
the power button

904
00:41:20,649 --> 00:41:22,110
that actually gives
you the ability

905
00:41:22,110 --> 00:41:24,089
to essentially gracefully sat

906
00:41:24,089 --> 00:41:26,830
down the system without
causing damage.

907
00:41:26,830 --> 00:41:29,530
And this is a set of interrupts

908
00:41:29,530 --> 00:41:32,169
that the kernel is
not allowed to mask,

909
00:41:32,169 --> 00:41:33,570
is not allowed to disable,

910
00:41:33,570 --> 00:41:35,790
not allowed to ignore.

911
00:41:36,070 --> 00:41:37,689
Okay?

912
00:41:37,689 --> 00:41:39,969
All right, so I mean,

913
00:41:39,969 --> 00:41:42,030
I don't know if we have time
for thought experiment,

914
00:41:42,030 --> 00:41:44,089
but for what it's worth,

915
00:41:44,089 --> 00:41:45,310
can you imagine building

916
00:41:45,310 --> 00:41:47,590
a keyboard driver
without interrupts?

917
00:41:47,590 --> 00:41:50,009
So I just told you that
we need interrupts in

918
00:41:50,009 --> 00:41:53,149
order to process keystrokes,
right? Is that true?

919
00:41:54,790 --> 00:41:57,289
Can you interact with

920
00:41:57,289 --> 00:41:59,350
the keyboard and your
operating system

921
00:41:59,350 --> 00:42:03,869
still being able to I'm trying
to be very careful here,

922
00:42:03,869 --> 00:42:05,809
receive the input you

923
00:42:05,809 --> 00:42:10,690
have provided to the system
by using a keyboard.

924
00:42:10,690 --> 00:42:12,049
Yeah, let me put it that way.

925
00:42:12,049 --> 00:42:14,810
Yes. Could constantly
pull the keyboard

926
00:42:14,810 --> 00:42:17,720
to see if there are new
keys yeah, exactly.

927
00:42:17,720 --> 00:42:19,839
So this is a pull

928
00:42:19,839 --> 00:42:23,339
versus push kind of a design
pattern in systems, right?

929
00:42:23,339 --> 00:42:25,759
It's going to come up in
other places as well,

930
00:42:25,759 --> 00:42:28,899
so you might I might as well
mention this now, right?

931
00:42:28,899 --> 00:42:31,959
We rely on interrupts
in order for us to

932
00:42:31,959 --> 00:42:34,800
sort of implement a push
based notification system.

933
00:42:34,800 --> 00:42:36,919
So we use interrupts to push

934
00:42:36,919 --> 00:42:38,179
a notification to

935
00:42:38,179 --> 00:42:40,319
the operating system
to the kernel that,

936
00:42:40,319 --> 00:42:42,019
Hey, I pressed, A,

937
00:42:42,019 --> 00:42:44,079
pay attention to me, right?

938
00:42:44,079 --> 00:42:45,740
Or we could pull

939
00:42:45,740 --> 00:42:48,220
for this information from
an operating system.

940
00:42:48,220 --> 00:42:50,200
I've got time right
now on my hands.

941
00:42:50,200 --> 00:42:51,500
I'm going to see if anything

942
00:42:51,500 --> 00:42:53,199
happened on my
device right there.

943
00:42:53,199 --> 00:42:55,079
So let me look at it now.

944
00:42:55,079 --> 00:42:57,600
Okay? So it is
actually possible,

945
00:42:57,600 --> 00:43:00,900
but it's called polling,

946
00:43:00,900 --> 00:43:02,380
and you would have
to keep checking

947
00:43:02,380 --> 00:43:04,219
for the events that
happened, right?

948
00:43:04,219 --> 00:43:05,919
In other words, you're not going

949
00:43:05,919 --> 00:43:07,700
to handle them asynchronously.

950
00:43:07,700 --> 00:43:10,660
You're going to actively
monitor those events

951
00:43:10,660 --> 00:43:14,919
and potentially blocking for
them to actually arrive.

952
00:43:14,919 --> 00:43:17,979
So what are the disadvantages
associated with that?

953
00:43:17,979 --> 00:43:22,865
Why is it not something that
we actually do very quickly?

954
00:43:22,865 --> 00:43:25,029
Yeah, you got to

955
00:43:25,029 --> 00:43:26,049
keep checking even though

956
00:43:26,049 --> 00:43:27,229
there might not be
something there.

957
00:43:27,229 --> 00:43:30,069
Yeah, you don't know if there's
something there, right?

958
00:43:30,069 --> 00:43:33,009
And so in a situation where

959
00:43:33,009 --> 00:43:36,549
the interrupts or the exceptions
are actually infrequent,

960
00:43:36,549 --> 00:43:39,030
you actually imposing
a lot of overhead,

961
00:43:39,030 --> 00:43:40,529
as you correctly pointed out,

962
00:43:40,529 --> 00:43:41,929
in order to keep checking for

963
00:43:41,929 --> 00:43:43,729
something that
statistically may not be

964
00:43:43,729 --> 00:43:48,009
there like 99 out of 100
times that you check, right?

965
00:43:48,009 --> 00:43:50,769
So that's pretty
wasteful, right?

966
00:43:50,769 --> 00:43:55,489
Um, and there are some
other disadvantages,

967
00:43:55,489 --> 00:43:57,829
especially when
you think about it

968
00:43:57,829 --> 00:44:01,770
as a mechanism for
handling device drivers.

969
00:44:01,770 --> 00:44:03,849
So, you know, for

970
00:44:03,849 --> 00:44:06,089
the sake for the sake of
this example, you know,

971
00:44:06,089 --> 00:44:07,949
imagine you have
limited buffers on

972
00:44:07,949 --> 00:44:09,169
the device driver and

973
00:44:09,169 --> 00:44:10,829
you keep pressing
the strokes, right,

974
00:44:10,829 --> 00:44:12,130
and the buffer starts

975
00:44:12,130 --> 00:44:14,429
to fill up and you
no longer have space

976
00:44:14,429 --> 00:44:16,169
to actually store
this information that

977
00:44:16,169 --> 00:44:18,679
you're trying to provide
through the device driver.

978
00:44:18,679 --> 00:44:20,649
Through the device, right?

979
00:44:20,649 --> 00:44:22,949
And so what happens as

980
00:44:22,949 --> 00:44:25,750
a result of this if you don't
have interrupts enabled,

981
00:44:25,750 --> 00:44:28,809
is that the key strokes
may actually start to

982
00:44:28,809 --> 00:44:31,189
disappear because
there's no more space

983
00:44:31,189 --> 00:44:32,769
to put the keystrokes, right?

984
00:44:32,769 --> 00:44:34,769
And so that's another
disadvantage.

985
00:44:34,769 --> 00:44:36,929
One of the disadvantages at

986
00:44:36,929 --> 00:44:39,389
a high level is a
performance disadvantage,

987
00:44:39,389 --> 00:44:42,130
lots of overhead,
unnecessary overhead.

988
00:44:42,130 --> 00:44:45,569
Another one is a
correctness disadvantage.

989
00:44:45,569 --> 00:44:48,309
Performance correctness,
high level.

990
00:44:48,309 --> 00:44:52,060
Okay. So every exception

991
00:44:52,060 --> 00:44:54,560
interrupt is actually
assigned a vector.

992
00:44:54,560 --> 00:44:56,419
So in XV six,

993
00:44:56,419 --> 00:44:58,500
vector 14 is a
page fold handler,

994
00:44:58,500 --> 00:44:59,259
and this is something

995
00:44:59,259 --> 00:45:01,259
that you might have
seen in lab two.

996
00:45:01,259 --> 00:45:04,779
Vector 32, this is going to be

997
00:45:04,779 --> 00:45:06,499
famous in Lab three

998
00:45:06,499 --> 00:45:09,139
because we need it for
scheduling implementation.

999
00:45:09,139 --> 00:45:11,280
This is basically
our clock handler,

1000
00:45:11,280 --> 00:45:12,820
and of course, the
clock handler,

1001
00:45:12,820 --> 00:45:14,739
it gives us an ability to

1002
00:45:14,739 --> 00:45:17,100
actually contact switch
between processes,

1003
00:45:17,100 --> 00:45:19,320
and that's why it's super
important for the scheduler.

1004
00:45:19,320 --> 00:45:21,620
Okay? And when an
interrupt occurs,

1005
00:45:21,620 --> 00:45:23,959
the vector determines
what is the code for an

1006
00:45:23,959 --> 00:45:25,540
interrupt and it invokes

1007
00:45:25,540 --> 00:45:27,940
the handler in order to
handle the interrupt.

1008
00:45:27,940 --> 00:45:30,379
Here's my very brief taxonomy.

1009
00:45:30,379 --> 00:45:32,339
So you have interrupts,

1010
00:45:32,339 --> 00:45:33,880
and there's two different

1011
00:45:33,880 --> 00:45:36,060
kinds hardware and
software interrupts.

1012
00:45:36,060 --> 00:45:38,319
And for the software
interrupt that

1013
00:45:38,319 --> 00:45:41,179
usually corresponds to that
corresponds not usually,

1014
00:45:41,179 --> 00:45:43,860
that corresponds
to an instruction.

1015
00:45:43,860 --> 00:45:46,980
So those are also known
as internal interrupts,

1016
00:45:46,980 --> 00:45:48,739
something that only
the software sees

1017
00:45:48,739 --> 00:45:51,080
and they're not
generated by hardware.

1018
00:45:51,080 --> 00:45:54,060
Okay. And for example,

1019
00:45:54,060 --> 00:45:57,840
cis calls I implemented
using an inter structure.

1020
00:45:57,880 --> 00:46:00,979
And we have hardware interrupts

1021
00:46:00,979 --> 00:46:03,140
that also are of two types.

1022
00:46:03,140 --> 00:46:04,759
Some of them you
can ignore, some

1023
00:46:04,759 --> 00:46:06,040
of them you cannot ignore.

1024
00:46:06,040 --> 00:46:07,600
The ones that you cannot ignore,

1025
00:46:07,600 --> 00:46:08,939
I already mentioned are called

1026
00:46:08,939 --> 00:46:11,640
non maskba interrupts or Nimis.

1027
00:46:11,640 --> 00:46:13,619
And the maskb
interrupts are sort

1028
00:46:13,619 --> 00:46:18,839
of given to the system
using the INTR instruction.

1029
00:46:18,839 --> 00:46:21,440
So those are the ones
that come from hardware,

1030
00:46:21,440 --> 00:46:24,260
but we have the ability

1031
00:46:24,260 --> 00:46:26,020
to sort of enable or
disable receiving

1032
00:46:26,020 --> 00:46:28,260
those interrupts by setting

1033
00:46:28,260 --> 00:46:32,480
the IF bit in the
E flex register.

1034
00:46:32,870 --> 00:46:34,329
Okay.

1035
00:46:34,329 --> 00:46:36,849
So this sort of is

1036
00:46:36,849 --> 00:46:40,810
just a summary slide of
what I just said, okay?

1037
00:46:40,810 --> 00:46:43,450
Non mascub they
never get ignored.

1038
00:46:43,450 --> 00:46:45,049
You know, they're useful for

1039
00:46:45,049 --> 00:46:46,829
power failure, memory
corruption, error.

1040
00:46:46,829 --> 00:46:48,489
XV six actually has it.

1041
00:46:48,489 --> 00:46:50,810
You know, it has a way of hand.

1042
00:46:50,810 --> 00:46:53,870
It has an implementation of
non mascubin interrupts.

1043
00:46:53,870 --> 00:46:55,370
And this is basically,

1044
00:46:55,370 --> 00:46:57,490
if we get a non
mascub interrupt,

1045
00:46:57,490 --> 00:47:01,529
we give the kernel an
opportunity to gracefully die.

1046
00:47:01,529 --> 00:47:05,210
So actually vector two in X 86.

1047
00:47:05,210 --> 00:47:08,350
INTR corresponds to
mascuba interrupts,

1048
00:47:08,350 --> 00:47:10,469
and this is basically
when you can

1049
00:47:10,469 --> 00:47:13,629
ignore them by setting the
IF bit and Efflex to zero.

1050
00:47:13,629 --> 00:47:15,069
Okay.

1051
00:47:15,830 --> 00:47:18,230
And the enabling disabling

1052
00:47:18,230 --> 00:47:20,289
actually happens with
those instructions.

1053
00:47:20,289 --> 00:47:23,110
The assembly
instructions basically

1054
00:47:23,110 --> 00:47:25,429
set interrupt and clear.

1055
00:47:25,429 --> 00:47:27,729
So the STI sets the IF flag,

1056
00:47:27,729 --> 00:47:29,409
CLI clears the IF flag.

1057
00:47:29,409 --> 00:47:33,010
So that's basically
how you can ignore

1058
00:47:33,010 --> 00:47:35,590
interrupts that are maskable

1059
00:47:35,590 --> 00:47:38,990
inside your handler,
for instance.

1060
00:47:39,090 --> 00:47:42,549
Okay. Another question
is basically we have

1061
00:47:42,549 --> 00:47:45,390
this programmable
interrupt controller.

1062
00:47:45,390 --> 00:47:46,729
It looks like this.

1063
00:47:46,729 --> 00:47:48,750
It's a pretty outdated picture,

1064
00:47:48,750 --> 00:47:52,389
but nevertheless, it's a
variant of something like this.

1065
00:47:52,389 --> 00:47:54,790
The question is, how many pins

1066
00:47:54,790 --> 00:47:56,429
do we need to
allocate on a piece

1067
00:47:56,429 --> 00:47:58,030
of hardware that actually

1068
00:47:58,030 --> 00:48:01,010
gives us hardware
interrupts to the CPU?

1069
00:48:04,970 --> 00:48:08,930
Is it 16? Is it 32?

1070
00:48:08,930 --> 00:48:12,590
Is it 64? Is it 128?

1071
00:48:12,590 --> 00:48:17,929
Can we change it after
we ship the motherboard?

1072
00:48:18,680 --> 00:48:21,719
It's pretty hard
to change, right?

1073
00:48:21,719 --> 00:48:25,459
And so associating a
hardware interrupt with

1074
00:48:25,459 --> 00:48:26,899
every single one
of those pins is

1075
00:48:26,899 --> 00:48:30,140
probably not a very
good design decision.

1076
00:48:30,140 --> 00:48:33,620
Because if we want to
implement a new interrupt,

1077
00:48:33,620 --> 00:48:35,559
we sort of don't have
the capacity to do it.

1078
00:48:35,559 --> 00:48:38,219
You need to redesign a new pick.

1079
00:48:38,219 --> 00:48:40,200
You know, you need to
ship a new motherboard.

1080
00:48:40,200 --> 00:48:42,519
It's a pretty stupid
thing to do, right?

1081
00:48:42,519 --> 00:48:44,500
And so what do we do instead?

1082
00:48:44,500 --> 00:48:46,179
Instead, what we do is we take

1083
00:48:46,179 --> 00:48:50,360
a single pin on this programmable
interrupt controller,

1084
00:48:50,360 --> 00:48:52,319
and we sort of multiplex

1085
00:48:52,319 --> 00:48:56,094
all hardware interrupts
through a single pin.

1086
00:48:56,094 --> 00:48:58,789
So in other words, if
you receive, let's say,

1087
00:48:58,789 --> 00:49:02,129
a network Ethernet frame,

1088
00:49:02,129 --> 00:49:05,150
right, or any other kind
of hardware interrupt,

1089
00:49:05,150 --> 00:49:07,330
it's not going to go
directly to your CPU.

1090
00:49:07,330 --> 00:49:08,449
It first goes through

1091
00:49:08,449 --> 00:49:10,190
your programmable
interrupt controller.

1092
00:49:10,190 --> 00:49:11,689
Your PIC is the one that sort

1093
00:49:11,689 --> 00:49:13,749
of interposes on that first.

1094
00:49:13,749 --> 00:49:15,970
It detects that activity.

1095
00:49:15,970 --> 00:49:18,390
It recognizes the type

1096
00:49:18,390 --> 00:49:22,250
of a hardware interrupt
it has just trapped,

1097
00:49:22,250 --> 00:49:24,690
right, or it has just noticed.

1098
00:49:24,690 --> 00:49:30,050
And then it sends this interrupt
through one of the pins,

1099
00:49:30,050 --> 00:49:32,369
and I think it's
this pin right here,

1100
00:49:32,369 --> 00:49:35,685
pin number 17 called INT.

1101
00:49:35,685 --> 00:49:38,620
Two hour X 86 CPU,

1102
00:49:38,620 --> 00:49:40,060
as you can see in the bottom

1103
00:49:40,060 --> 00:49:42,179
right hand side of this slide.

1104
00:49:42,179 --> 00:49:45,040
Okay. And it delivers

1105
00:49:45,040 --> 00:49:47,219
both non mascubll interrupts and

1106
00:49:47,219 --> 00:49:50,200
maskeb hardware interrupts
in this fashion.

1107
00:49:50,200 --> 00:49:51,639
So clearly, this gives us

1108
00:49:51,639 --> 00:49:53,919
the ability to support
an arbitrary number of

1109
00:49:53,919 --> 00:49:56,160
hardware interrupts
without having to modify

1110
00:49:56,160 --> 00:49:58,920
the programmable
interrupt controller.

1111
00:49:58,920 --> 00:50:02,249
Okay? Okay, yeah.

1112
00:50:02,249 --> 00:50:04,570
And here I have basically

1113
00:50:04,570 --> 00:50:07,469
showing that the
17th pin here kind

1114
00:50:07,469 --> 00:50:10,249
of is the mechanism
that gets used

1115
00:50:10,249 --> 00:50:13,390
for us to deliver hardware
interrupts to Xe six CPU.

1116
00:50:13,390 --> 00:50:15,570
And then when it gets
to Xeight six CPU,

1117
00:50:15,570 --> 00:50:20,250
it gives us the ability
to handle that interrupt.

1118
00:50:20,250 --> 00:50:22,850
Okay, and how do we
handle those interrupts.

1119
00:50:22,850 --> 00:50:25,309
Software interrupts or
basically interrupts that

1120
00:50:25,309 --> 00:50:28,030
are kind of triggered
in software.

1121
00:50:28,030 --> 00:50:30,389
So this is not initiating

1122
00:50:30,389 --> 00:50:32,010
from any hardware in the system.

1123
00:50:32,010 --> 00:50:34,029
This is a piece of software that

1124
00:50:34,029 --> 00:50:37,809
explicitly decided to
raise the red light,

1125
00:50:37,809 --> 00:50:40,169
decided to raise the
exception in some sense,

1126
00:50:40,169 --> 00:50:44,549
the intentional interrupts
to the control tool.

1127
00:50:44,549 --> 00:50:46,210
Actually, it provides

1128
00:50:46,210 --> 00:50:48,090
the interstruption
for this purpose,

1129
00:50:48,090 --> 00:50:50,790
and it can invoke the interrupt
handler for the vector.

1130
00:50:50,790 --> 00:50:53,629
Vector is anywhere 0-5.

1131
00:50:53,629 --> 00:50:56,630
For example, for Titmva and it,

1132
00:50:56,630 --> 00:50:59,750
you have interrupt a number 64

1133
00:50:59,750 --> 00:51:03,030
or zero x 40 in order to
implement system calls.

1134
00:51:03,030 --> 00:51:04,249
That's the one
you're going to be

1135
00:51:04,249 --> 00:51:06,489
familiar with the
most in this class.

1136
00:51:06,489 --> 00:51:08,169
They have to be very careful how

1137
00:51:08,169 --> 00:51:09,809
you enter and leave
the interrupt and

1138
00:51:09,809 --> 00:51:11,149
the reason for this is

1139
00:51:11,149 --> 00:51:14,070
because it's a
privileged instruction.

1140
00:51:14,070 --> 00:51:16,449
Typically, I would leave
that the question.

1141
00:51:16,449 --> 00:51:19,849
Should we allow a user
space application to

1142
00:51:19,849 --> 00:51:21,910
just arbitrarily
issue interrupts

1143
00:51:21,910 --> 00:51:24,269
into our interact vector table.

1144
00:51:24,269 --> 00:51:27,749
Should should everything in
the interrupt vector table

1145
00:51:27,749 --> 00:51:32,829
be accessible for the
application to invoke?

1146
00:51:32,829 --> 00:51:35,189
Of course, the
answer is no. So how

1147
00:51:35,189 --> 00:51:37,650
do we prevent that
from happening?

1148
00:51:38,280 --> 00:51:40,719
Well, so we prevent that from

1149
00:51:40,719 --> 00:51:42,439
happening in a number of ways.

1150
00:51:42,439 --> 00:51:44,879
One of them is actually
detecting whether or not

1151
00:51:44,879 --> 00:51:48,320
the current privileged
privilege level matches

1152
00:51:48,320 --> 00:51:51,379
the descriptor
privilege level for

1153
00:51:51,379 --> 00:51:55,799
the descriptor in the
interrupt vector table.

1154
00:51:55,799 --> 00:51:57,639
Okay? And there's
actually a code in

1155
00:51:57,639 --> 00:52:00,019
XV six where the
interrupt vector table,

1156
00:52:00,019 --> 00:52:01,559
the IVT is set up,

1157
00:52:01,559 --> 00:52:07,399
and there's a macro that sets
up the descriptors in IVT,

1158
00:52:07,399 --> 00:52:09,639
and one of the flags
in that vector

1159
00:52:09,639 --> 00:52:12,619
is the GPL, descriptor
privilege level.

1160
00:52:12,619 --> 00:52:15,659
And basically, we check for
the GPL to make sure if we

1161
00:52:15,659 --> 00:52:19,279
should allow or disallow the
trap to actually preceed.

1162
00:52:19,279 --> 00:52:21,459
In addition to this,
we also need to

1163
00:52:21,459 --> 00:52:23,239
save some state in order for

1164
00:52:23,239 --> 00:52:28,519
us to actually again,

1165
00:52:28,519 --> 00:52:29,999
I could also phrase
it as a question.

1166
00:52:29,999 --> 00:52:33,519
Do we want to handle the
interrupt on the user's stack?

1167
00:52:33,790 --> 00:52:37,010
So remember that we
took an interrupt.

1168
00:52:37,010 --> 00:52:38,589
You have some state. This state

1169
00:52:38,589 --> 00:52:40,210
is captured by a
set of registers.

1170
00:52:40,210 --> 00:52:42,749
There's no magic here,
or rather it is magic,

1171
00:52:42,749 --> 00:52:46,109
but the magic is captured by
the set of registers, right?

1172
00:52:46,109 --> 00:52:48,570
And one of those
registers is ESP,

1173
00:52:48,570 --> 00:52:52,349
our stack pointer, another
register is SS, right?

1174
00:52:52,349 --> 00:52:54,910
Our stack segment register.

1175
00:52:54,910 --> 00:52:58,569
And we've just captured
an interrupt and they are

1176
00:52:58,569 --> 00:53:02,310
set to the user space
kernel context.

1177
00:53:02,310 --> 00:53:04,630
Do we want to proceed
with handling

1178
00:53:04,630 --> 00:53:07,524
this interrupt on
the user stack?

1179
00:53:07,524 --> 00:53:09,959
The answer is no, right?

1180
00:53:09,959 --> 00:53:11,619
So we don't want to do that.

1181
00:53:11,619 --> 00:53:14,579
We actually want to swap out

1182
00:53:14,579 --> 00:53:16,619
the user's stack or move

1183
00:53:16,619 --> 00:53:19,699
away rather from user stack
into the kernel stack,

1184
00:53:19,699 --> 00:53:21,259
save all of that state, and come

1185
00:53:21,259 --> 00:53:23,500
back to that state on the RT.

1186
00:53:23,500 --> 00:53:25,899
So the implementation of IRT is

1187
00:53:25,899 --> 00:53:29,559
basically it basically involves

1188
00:53:29,559 --> 00:53:32,739
restoring all of the
user space state that

1189
00:53:32,739 --> 00:53:36,279
we had when we received an
interrupt in the first place.

1190
00:53:36,279 --> 00:53:38,199
So let me see if Oh,
it's actually in

1191
00:53:38,199 --> 00:53:40,559
the next slide.
Perfect. Right here.

1192
00:53:40,559 --> 00:53:43,060
As long as it takes.

1193
00:53:43,590 --> 00:53:46,329
I can get through this now

1194
00:53:46,329 --> 00:53:48,849
or you can go through
this on your own.

1195
00:53:48,849 --> 00:53:51,409
But basically, it captures
in its entirety what

1196
00:53:51,409 --> 00:53:54,110
happens when you receive an
instruction in the kernel.

1197
00:53:54,110 --> 00:53:55,870
It has the following steps.

1198
00:53:55,870 --> 00:53:58,749
You decide the vector number
because that gives you

1199
00:53:58,749 --> 00:54:01,990
essentially an index
into IVT, okay?

1200
00:54:01,990 --> 00:54:03,970
As part of for example,

1201
00:54:03,970 --> 00:54:09,409
in a zero x 40 zerox
40 instruction

1202
00:54:09,409 --> 00:54:12,269
with zero x 40, that
would be the number.

1203
00:54:12,269 --> 00:54:14,489
Then you fetch the
interrupt descriptor from

1204
00:54:14,489 --> 00:54:17,439
IVT for this vector
number, right?

1205
00:54:17,439 --> 00:54:20,369
IGT stands for Interrupt
descriptor table.

1206
00:54:20,369 --> 00:54:21,989
How do I remember this?

1207
00:54:21,989 --> 00:54:26,129
The CPU finds it by taking
the eight byte entry,

1208
00:54:26,129 --> 00:54:28,029
starting at the
physical address that

1209
00:54:28,029 --> 00:54:30,349
the IDTRCPURgister points to.

1210
00:54:30,349 --> 00:54:32,869
Then what I mentioned is
that you got to make sure

1211
00:54:32,869 --> 00:54:35,649
that you check that your
current privilege level,

1212
00:54:35,649 --> 00:54:37,669
remember those rings
of protection, right?

1213
00:54:37,669 --> 00:54:39,509
They come in and
play here again.

1214
00:54:39,509 --> 00:54:41,289
It's a very concrete use case

1215
00:54:41,289 --> 00:54:43,590
for using the rings
of protection.

1216
00:54:43,590 --> 00:54:46,469
You check that your
current privilege level is

1217
00:54:46,469 --> 00:54:48,809
less than equal to

1218
00:54:48,809 --> 00:54:51,489
the descriptor
privilege level in

1219
00:54:51,489 --> 00:54:55,354
the descriptor that you've
just fetched from IDT, right?

1220
00:54:55,354 --> 00:54:58,399
Then you save the
stack pointer and

1221
00:54:58,399 --> 00:55:02,019
the stack segment in a
CPU internal register,

1222
00:55:02,820 --> 00:55:05,599
and then you load this point,

1223
00:55:05,599 --> 00:55:08,820
the new stack pointer and
the stack segment from TSS,

1224
00:55:08,820 --> 00:55:10,719
which is a special
table where you save

1225
00:55:10,719 --> 00:55:14,040
this kernel stack information.

1226
00:55:14,040 --> 00:55:16,239
Okay? So now you are no longer

1227
00:55:16,239 --> 00:55:18,239
on user space on user stack,

1228
00:55:18,239 --> 00:55:19,839
you are now on Kernel stack.

1229
00:55:19,839 --> 00:55:22,800
And then you push the
user stack information,

1230
00:55:22,800 --> 00:55:24,499
which is the SS and ESP,

1231
00:55:24,499 --> 00:55:29,820
you push the E flag which is
your control flag register,

1232
00:55:29,820 --> 00:55:31,599
and you push CS and EIP, right?

1233
00:55:31,599 --> 00:55:34,039
You basically push the
state for the user,

1234
00:55:34,039 --> 00:55:36,499
you clear some EFLx
because now you're in

1235
00:55:36,499 --> 00:55:40,280
kernel space and right before
you get into the handler.

1236
00:55:40,280 --> 00:55:42,419
And finally, how do you
get to the handler?

1237
00:55:42,419 --> 00:55:45,099
You set the CS and EIP that are

1238
00:55:45,099 --> 00:55:47,099
stored in the interrupt
descriptor table,

1239
00:55:47,099 --> 00:55:48,719
descriptor, okay?

1240
00:55:48,719 --> 00:55:51,899
You now set the CSE
and EIP and you jump,

1241
00:55:51,899 --> 00:55:54,659
and now you're in
the handler code.

1242
00:55:55,130 --> 00:55:57,570
So it seems quite involved,

1243
00:55:57,570 --> 00:55:59,849
but at a high level, you know,

1244
00:55:59,849 --> 00:56:02,189
if you didn't follow
that, that's okay, okay?

1245
00:56:02,189 --> 00:56:05,229
Because here's the high level.
The high level is this.

1246
00:56:05,229 --> 00:56:06,829
You figure out, what

1247
00:56:06,829 --> 00:56:08,609
is the interrupt number
that I'm getting.

1248
00:56:08,609 --> 00:56:11,669
Then you check. Is it okay
for me to run this interrupt?

1249
00:56:11,669 --> 00:56:13,250
Then you switch stacks.

1250
00:56:13,250 --> 00:56:15,789
So all of these pushes
and yada, yada,

1251
00:56:15,789 --> 00:56:19,230
you know, this is all about
switching stacks, okay?

1252
00:56:19,230 --> 00:56:21,129
And because you don't want

1253
00:56:21,129 --> 00:56:23,374
to perform handling
on the user stack.

1254
00:56:23,374 --> 00:56:26,239
Then you set up
registers by saving them

1255
00:56:26,239 --> 00:56:29,140
and making changes
to the E flex bits,

1256
00:56:29,140 --> 00:56:30,799
and then you finally jump to

1257
00:56:30,799 --> 00:56:33,240
the kernel handler by setting

1258
00:56:33,240 --> 00:56:35,199
the CSIP because CSIP is

1259
00:56:35,199 --> 00:56:37,920
a code segment,
instruction pointer,

1260
00:56:37,920 --> 00:56:41,459
pair that controls
which instruction

1261
00:56:41,459 --> 00:56:43,979
is going to be executed next,

1262
00:56:43,979 --> 00:56:48,500
and you get the CSIP pair
from the IDT descriptor,

1263
00:56:48,500 --> 00:56:51,940
from interrupt descriptor
table descriptor.

1264
00:56:51,940 --> 00:56:55,299
And that is how you get
into the handler code.

1265
00:56:55,299 --> 00:56:58,969
Okay? So this is the trap frame.

1266
00:56:58,969 --> 00:57:01,539
I already showed you
this slide before.

1267
00:57:01,539 --> 00:57:05,099
Basically this is how we define
interrupts for cis calls.

1268
00:57:05,099 --> 00:57:09,560
Okay? It's a macro that's
defined and uses DRS.

1269
00:57:09,560 --> 00:57:11,359
And yeah, here's where the

1270
00:57:11,359 --> 00:57:13,099
interrupt is actually
being invoked.

1271
00:57:13,099 --> 00:57:15,700
It's being invoked with
a T on the score ciscol

1272
00:57:15,700 --> 00:57:19,299
which is the zero x 40 that
I keep talking about, right?

1273
00:57:19,299 --> 00:57:22,719
Okay. And IRT is what

1274
00:57:22,719 --> 00:57:26,800
you call when you try to
return from the handler,

1275
00:57:27,080 --> 00:57:30,379
and that attempts to restore

1276
00:57:30,379 --> 00:57:32,639
the user space stack
before it hands

1277
00:57:32,639 --> 00:57:36,080
control back to the
user space process.

1278
00:57:36,080 --> 00:57:37,579
Okay.

1279
00:57:37,579 --> 00:57:43,099
And yeah, we can stop here.

1280
00:57:43,099 --> 00:57:46,780
This is basically how the
IDT is set up on TV Nt.

1281
00:57:46,780 --> 00:57:50,319
And you can see that the
only place where the user

1282
00:57:50,319 --> 00:57:54,339
can actually access the handler

1283
00:57:54,339 --> 00:57:55,959
is for

1284
00:58:02,320 --> 00:58:04,359
A

1285
00:58:39,850 --> 00:58:41,889
Okay.
