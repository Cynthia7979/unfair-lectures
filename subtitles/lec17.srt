1
00:00:03,240 --> 00:00:05,280
A

2
00:00:16,720 --> 00:00:19,040
s

3
00:00:55,840 --> 00:00:58,040
good

4
00:01:09,610 --> 00:01:11,329
All right, everyone.

5
00:01:11,329 --> 00:01:15,990
Good afternoon. We have
a big day ahead of us.

6
00:01:15,990 --> 00:01:19,070
Today we're talking about
midterm exam preparation.

7
00:01:19,070 --> 00:01:21,110
We also have a big
week ahead of us.

8
00:01:21,110 --> 00:01:23,030
And, of course, as you all know,

9
00:01:23,030 --> 00:01:24,670
next week is going
to be all about

10
00:01:24,670 --> 00:01:28,589
the midterm and your
checkpoint one due on Friday,

11
00:01:28,589 --> 00:01:29,930
next week as well, right?

12
00:01:29,930 --> 00:01:32,890
So pretty big and
heavy week ahead.

13
00:01:32,890 --> 00:01:36,970
And hopefully this lecture
is going to give you

14
00:01:37,140 --> 00:01:40,800
helpful tips for
you to be able to

15
00:01:40,800 --> 00:01:42,520
approach the kinds
of questions that

16
00:01:42,520 --> 00:01:45,460
we're going to be
asking on the exam.

17
00:01:45,460 --> 00:01:48,100
Let's go ahead and get started.

18
00:01:48,100 --> 00:01:50,740
A few reminders, lab
three Checkpoint

19
00:01:50,740 --> 00:01:52,599
as I mentioned, is
going to be on Friday,

20
00:01:52,599 --> 00:01:55,100
the Pi Day 314,

21
00:01:55,820 --> 00:01:59,039
the full lab is going
to be due two weeks

22
00:01:59,039 --> 00:02:02,520
afterwards on 28 March.

23
00:02:02,520 --> 00:02:05,460
And the office hours

24
00:02:05,460 --> 00:02:07,099
basically are going
to be affected

25
00:02:07,099 --> 00:02:08,939
by whatever's going
to happen next week.

26
00:02:08,939 --> 00:02:10,279
So typically, when there's

27
00:02:10,279 --> 00:02:12,000
only one section, historically,

28
00:02:12,000 --> 00:02:14,120
there's only been one
section in this class,

29
00:02:14,120 --> 00:02:17,440
we would cancel the office
hours on the day of the exam.

30
00:02:17,440 --> 00:02:19,659
And so I'm planning to

31
00:02:19,659 --> 00:02:22,660
not have office hours
on Tuesday the 311.

32
00:02:22,660 --> 00:02:24,799
The reason for this
is because there's

33
00:02:24,799 --> 00:02:27,400
a withdrawal deadline
on Wednesday 312.

34
00:02:27,400 --> 00:02:29,439
And as I mentioned previously,

35
00:02:29,439 --> 00:02:32,800
we want to make sure we grade

36
00:02:32,800 --> 00:02:34,800
the midterms for you guys

37
00:02:34,800 --> 00:02:38,120
before the Wednesday 4:00
P.M. Withdrawal deadline,

38
00:02:38,120 --> 00:02:40,279
which is a 24 hour
turnaround time.

39
00:02:40,279 --> 00:02:42,659
I hope you appreciate
the amount of effort and

40
00:02:42,659 --> 00:02:46,609
coordination this is going
to involve across 12 people.

41
00:02:46,609 --> 00:02:50,120
So we'll be busy doing stuff.

42
00:02:50,120 --> 00:02:52,400
And so we're going
to try to figure

43
00:02:52,400 --> 00:02:54,340
out how that's going
to work logistically.

44
00:02:54,340 --> 00:02:56,699
And so we'll make
announcements in terms of

45
00:02:56,699 --> 00:02:59,540
how that's going to affect
office hours next week, okay?

46
00:02:59,540 --> 00:03:01,019
So, you know,

47
00:03:01,019 --> 00:03:03,120
whatever questions you
have about your labs,

48
00:03:03,120 --> 00:03:05,499
especially the ones that are
targeting the checkpoint,

49
00:03:05,499 --> 00:03:07,259
your tests one through 21,

50
00:03:07,259 --> 00:03:11,180
you know, make sure you
ask them not on Tuesday,

51
00:03:11,180 --> 00:03:15,559
next week and possibly not
on Monday after 6:00 P.M.

52
00:03:15,559 --> 00:03:17,860
Next week, okay?

53
00:03:17,860 --> 00:03:20,779
Alright, so the exam for

54
00:03:20,779 --> 00:03:23,839
the Section Section C is
going to be on Tuesday,

55
00:03:23,839 --> 00:03:27,239
March 11 here,
regular classroom.

56
00:03:27,239 --> 00:03:29,439
Okay. The exam instructions.

57
00:03:29,439 --> 00:03:32,680
So I've already included
them in the practice exam,

58
00:03:32,680 --> 00:03:34,860
and I'm probably going to copy

59
00:03:34,860 --> 00:03:37,260
paste them into the actual exam.

60
00:03:37,260 --> 00:03:40,940
You will see them also
posted on Paz and Canvas.

61
00:03:40,940 --> 00:03:44,119
I want to remind
everyone that we

62
00:03:44,119 --> 00:03:48,240
cannot allow the use of
Internet in general.

63
00:03:48,240 --> 00:03:51,799
And specifically, we cannot
allow the use of GII.

64
00:03:51,799 --> 00:03:54,839
It has become way
too powerful to

65
00:03:54,839 --> 00:03:56,180
the point that it
can pretty much

66
00:03:56,180 --> 00:03:58,259
solve a lot of the things
that we're asking.

67
00:03:58,259 --> 00:03:59,839
And so, you know, we want to

68
00:03:59,839 --> 00:04:01,419
figure out how you
guys are learning,

69
00:04:01,419 --> 00:04:03,099
and to what extent,
we've been successful

70
00:04:03,099 --> 00:04:05,539
actually teaching you something
in this class, right?

71
00:04:05,539 --> 00:04:09,799
Um, and also, frankly,

72
00:04:09,799 --> 00:04:11,640
you don't want to GNAI

73
00:04:11,640 --> 00:04:13,899
yourself out of the
marketplace completely, right?

74
00:04:13,899 --> 00:04:15,480
You want to be able to
think for yourself.

75
00:04:15,480 --> 00:04:16,620
Otherwise, you'll be one of

76
00:04:16,620 --> 00:04:18,600
those programmers that
will be displaced.

77
00:04:18,600 --> 00:04:20,379
So try to be better than GeneI.

78
00:04:20,379 --> 00:04:21,880
The only way to
achieve that is to

79
00:04:21,880 --> 00:04:24,360
actually do stuff on your own.

80
00:04:25,240 --> 00:04:29,659
Okay, and as I
mentioned on Piazza,

81
00:04:29,659 --> 00:04:35,320
we did post the practice
questions on Canvas.

82
00:04:35,320 --> 00:04:36,960
How many of you
have had a chance

83
00:04:36,960 --> 00:04:38,959
to actually go through
those questions?

84
00:04:38,959 --> 00:04:41,760
You raise your hands
higher? This is

85
00:04:41,760 --> 00:04:43,780
better than the previous
section. That's good.

86
00:04:43,780 --> 00:04:46,840
I'm proud of you
guys. It's very nice.

87
00:04:46,840 --> 00:04:48,360
So just to give you a sense.

88
00:04:48,360 --> 00:04:50,939
So this was a typical
length of the exam,

89
00:04:50,939 --> 00:04:53,579
targeting an hour
and 15 minutes.

90
00:04:53,579 --> 00:04:55,020
So don't worry.

91
00:04:55,020 --> 00:04:57,779
This is not a 50
minute exam, okay?

92
00:04:57,779 --> 00:04:59,840
It's a lot for a 50 minute exam,

93
00:04:59,840 --> 00:05:01,500
but I wanted to go
ahead and give you

94
00:05:01,500 --> 00:05:03,219
all of those six
questions anyway,

95
00:05:03,219 --> 00:05:04,840
so that you actually
have more practice

96
00:05:04,840 --> 00:05:05,980
than what we would

97
00:05:05,980 --> 00:05:09,560
typically share in
the practice exam.

98
00:05:09,560 --> 00:05:14,990
And okay, so you know, I
have to get through this.

99
00:05:14,990 --> 00:05:16,869
It's also going to
be on the slides.

100
00:05:16,869 --> 00:05:18,430
The slides are
going to be posted,

101
00:05:18,430 --> 00:05:20,389
and this is essentially
a formality,

102
00:05:20,389 --> 00:05:23,089
but I think you all know what
to expect at this point.

103
00:05:23,089 --> 00:05:25,169
In case you don't follow

104
00:05:25,169 --> 00:05:27,510
this please go back

105
00:05:27,510 --> 00:05:29,689
and refer to this slide
at your convenience.

106
00:05:29,689 --> 00:05:32,489
It'll be in person, in
class, on your laptop.

107
00:05:32,489 --> 00:05:34,310
Make sure your
laptop is charged.

108
00:05:34,310 --> 00:05:35,150
As you can see,

109
00:05:35,150 --> 00:05:37,350
there are no charging
stations at the desk,

110
00:05:37,350 --> 00:05:39,709
which is somewhat concerning,

111
00:05:39,709 --> 00:05:41,470
but we do have charge stations

112
00:05:41,470 --> 00:05:43,070
on the side if you need one,

113
00:05:43,070 --> 00:05:44,630
but please don't need one.

114
00:05:44,630 --> 00:05:46,870
And you cannot expect
the course staff to

115
00:05:46,870 --> 00:05:49,410
provide you with lone
laptops or adapters.

116
00:05:49,410 --> 00:05:50,650
They're all different. We do

117
00:05:50,650 --> 00:05:53,010
not have the
capacity to do that.

118
00:05:53,010 --> 00:05:55,230
The exam will be released,

119
00:05:55,230 --> 00:05:58,370
I E visible on Canvas
precisely at 1,400

120
00:05:58,370 --> 00:06:02,849
Eastern on Tuesday
of the exam, okay?

121
00:06:02,849 --> 00:06:04,670
And the access to the exam will

122
00:06:04,670 --> 00:06:07,669
cease to exist at 14:50 Eastern.

123
00:06:07,669 --> 00:06:10,949
Please do bring your bus
card. It's a proctored exam.

124
00:06:10,949 --> 00:06:12,970
We'll be walking around and

125
00:06:12,970 --> 00:06:14,390
checking your bus cards to make

126
00:06:14,390 --> 00:06:16,310
sure you is you
and you are here.

127
00:06:16,310 --> 00:06:18,689
I like to summarize
this as saying,

128
00:06:18,689 --> 00:06:20,370
You are here and you are you.

129
00:06:20,370 --> 00:06:23,355
I think that pretty much
captures it, right?

130
00:06:23,355 --> 00:06:26,439
Answer all of the questions
to the best of your ability.

131
00:06:26,439 --> 00:06:28,100
As you can tell, it's
actually pretty hard

132
00:06:28,100 --> 00:06:30,199
to navigate around the rows.

133
00:06:30,199 --> 00:06:31,980
So if someone right there in

134
00:06:31,980 --> 00:06:34,259
the middle where three
of you guys are sitting,

135
00:06:34,259 --> 00:06:35,760
that's a pretty bad place to

136
00:06:35,760 --> 00:06:37,660
ask any questions
during the exam.

137
00:06:37,660 --> 00:06:39,899
It's going to be pretty
hard to get to you.

138
00:06:39,899 --> 00:06:43,660
And so, you know, if you
just want to double check if

139
00:06:43,660 --> 00:06:45,040
the assumption you're making is

140
00:06:45,040 --> 00:06:47,260
correct or anything of the sort,

141
00:06:47,260 --> 00:06:49,400
just write down any
reasonable assumptions

142
00:06:49,400 --> 00:06:50,680
you were making, okay?

143
00:06:50,680 --> 00:06:52,040
And then we'll try to work with

144
00:06:52,040 --> 00:06:54,315
those assumptions when
we're grading the exam.

145
00:06:54,315 --> 00:06:55,670
And this is going to save

146
00:06:55,670 --> 00:06:56,950
you time because
as you can tell,

147
00:06:56,950 --> 00:06:58,890
50 minutes passes by super fast.

148
00:06:58,890 --> 00:07:01,570
And, you know, in
a blink of an eye,

149
00:07:01,570 --> 00:07:03,990
you're going to be finished
with question one,

150
00:07:03,990 --> 00:07:05,190
and I can guarantee you that

151
00:07:05,190 --> 00:07:06,290
you'll be staring at the clock.

152
00:07:06,290 --> 00:07:08,389
I'll say 30 minutes.

153
00:07:08,660 --> 00:07:10,880
This has happened in the past,

154
00:07:10,880 --> 00:07:13,319
and that's I'm speaking
from experience, okay?

155
00:07:13,319 --> 00:07:16,619
So, make sure that
you just don't

156
00:07:16,619 --> 00:07:18,259
waste your time
waiting for the TAs to

157
00:07:18,259 --> 00:07:20,239
stop by and answer
your questions, okay?

158
00:07:20,239 --> 00:07:23,700
Do not block on that. Do not
take a dependency on that.

159
00:07:23,980 --> 00:07:28,179
Okay, all use of Internet,

160
00:07:28,179 --> 00:07:31,520
other than to access the
exam through Canvas,

161
00:07:31,520 --> 00:07:33,359
is going to be disallowed.

162
00:07:33,359 --> 00:07:37,980
So I E, this is an open
notes, closed Internet exam.

163
00:07:37,980 --> 00:07:39,780
I've been told that
people through

164
00:07:39,780 --> 00:07:42,319
the first two years of Georgia
Tech know what that means.

165
00:07:42,319 --> 00:07:45,219
Open notes, closed
Internet exam.

166
00:07:45,219 --> 00:07:50,440
Okay? Um, No CGPT,

167
00:07:50,440 --> 00:07:52,880
Jim and co pilot grow
Claude, Deep Seek,

168
00:07:52,880 --> 00:07:56,299
okay, and other generative
AI technologies, et cetera.

169
00:07:56,299 --> 00:07:58,720
I've already explained
the reason for this,

170
00:07:58,720 --> 00:08:00,659
we're not trying to
be hard on purpose.

171
00:08:00,659 --> 00:08:03,610
We're trying to help you
and foster learning.

172
00:08:03,610 --> 00:08:05,680
Let's see. You know,

173
00:08:05,680 --> 00:08:07,619
don't watch lecture recordings.

174
00:08:07,619 --> 00:08:10,879
While I appreciate you watching
the lecture recordings.

175
00:08:10,879 --> 00:08:13,820
This is not a good use
of time during the exam.

176
00:08:13,820 --> 00:08:15,640
It's also going to
be logistically

177
00:08:15,640 --> 00:08:18,019
complicated and distracting
for your neighbors.

178
00:08:18,019 --> 00:08:20,199
So we're just going to,
as a matter of policy,

179
00:08:20,199 --> 00:08:23,040
just kind of declaratively
specify, don't do it, okay?

180
00:08:23,040 --> 00:08:24,960
It just doesn't make
sense to do it.

181
00:08:24,960 --> 00:08:27,320
I would survive if you did it,

182
00:08:27,320 --> 00:08:29,900
but it would be distracting
for other people,

183
00:08:29,900 --> 00:08:32,440
and I don't think it
will be helpful to you.

184
00:08:33,160 --> 00:08:35,919
Yeah, let's see.

185
00:08:35,919 --> 00:08:37,519
And any questions about

186
00:08:37,519 --> 00:08:40,679
this set of Exam
one instructions?

187
00:08:40,679 --> 00:08:46,839
Yeah. Like paper or They can
be on your laptop. Yeah.

188
00:08:46,839 --> 00:08:49,400
So any static content
on your laptop,

189
00:08:49,400 --> 00:08:52,259
static content, okay?
No interactive.

190
00:08:52,259 --> 00:08:57,059
No Lama 37 billion running on

191
00:08:57,059 --> 00:09:02,759
your laptop with a huge RTX
28 TI mobile. Don't do that.

192
00:09:03,280 --> 00:09:06,739
You know how it's done. My
students are doing that.

193
00:09:06,739 --> 00:09:08,660
So don't do that
during the exam.

194
00:09:08,660 --> 00:09:11,359
Like, that's why I
specifically called out

195
00:09:11,359 --> 00:09:14,220
GNAI because even if
it is closed Internet,

196
00:09:14,220 --> 00:09:16,959
you could theoretically use
GAI in your local laptop.

197
00:09:16,959 --> 00:09:19,500
Don't do that either.
That's disallowed.

198
00:09:19,500 --> 00:09:22,599
Any other questions? Yeah.

199
00:09:26,640 --> 00:09:30,699
Yeah, it's local static
content, that's allowed.

200
00:09:30,699 --> 00:09:31,879
Yes.

201
00:09:35,920 --> 00:09:38,960
Any other questions?

202
00:09:42,720 --> 00:09:45,179
Okay, let's see.

203
00:09:45,179 --> 00:09:47,160
Yeah, and it's going
to be individual.

204
00:09:47,160 --> 00:09:50,239
Some people a handful of people

205
00:09:50,239 --> 00:09:52,780
sometimes finds that surprising

206
00:09:52,780 --> 00:09:54,260
because you guys are now working

207
00:09:54,260 --> 00:09:56,080
with the partner, whatnot.

208
00:09:56,080 --> 00:10:00,239
But of course, the exam is
going to be individual work.

209
00:10:00,239 --> 00:10:02,789
Nothing can be discussed.

210
00:10:02,789 --> 00:10:06,859
Except with the course staff
in any format whatsoever,

211
00:10:06,859 --> 00:10:08,860
everyone must turn
in their own exam.

212
00:10:08,860 --> 00:10:11,420
Do not expect your partner
to turn in your exam.

213
00:10:11,420 --> 00:10:13,139
I'm just saying the obvious,

214
00:10:13,139 --> 00:10:14,519
but I have to do this because

215
00:10:14,519 --> 00:10:16,159
one person will
come back and say,

216
00:10:16,159 --> 00:10:18,900
You didn't say that, and
therefore, I'm correct.

217
00:10:18,900 --> 00:10:20,479
Okay, so goals for

218
00:10:20,479 --> 00:10:23,620
today is to help clarify the
questions about the exam.

219
00:10:23,620 --> 00:10:24,959
I believe we've
gone through that

220
00:10:24,959 --> 00:10:27,340
and to go over the
practice exam.

221
00:10:27,340 --> 00:10:30,320
So, actually, how many
of you have gone through

222
00:10:30,320 --> 00:10:32,319
the exam in its entirety and are

223
00:10:32,319 --> 00:10:34,180
feeling comfortable
at this point.

224
00:10:34,180 --> 00:10:36,299
Like, you feel like, nice.

225
00:10:36,299 --> 00:10:38,419
So we have any other people

226
00:10:38,419 --> 00:10:40,660
feel comfortable with the exam?

227
00:10:41,400 --> 00:10:47,319
Go ahead and leave
now. I'm kidding.

228
00:10:47,319 --> 00:10:49,240
I think this is still going
to be useful for you.

229
00:10:49,240 --> 00:10:52,260
So this is a set of topics
of particular interest.

230
00:10:52,260 --> 00:10:54,580
I've already mentioned
this before.

231
00:10:54,580 --> 00:10:56,339
Isolation and protection.

232
00:10:56,339 --> 00:10:57,739
You know, we keep coming back to

233
00:10:57,739 --> 00:11:00,020
these two operating
system functions in

234
00:11:00,020 --> 00:11:01,919
the context of different kind of

235
00:11:01,919 --> 00:11:04,699
verticals in the kernel,
how they are provided.

236
00:11:04,699 --> 00:11:06,340
What are the
mechanisms for them?

237
00:11:06,340 --> 00:11:09,619
What are the policies that
govern the use, right?

238
00:11:09,619 --> 00:11:12,420
So we really want to
make sure that we ask

239
00:11:12,420 --> 00:11:14,000
kind of interesting
creative questions

240
00:11:14,000 --> 00:11:15,935
about isolation and protection.

241
00:11:15,935 --> 00:11:18,150
The trade offs
associated between

242
00:11:18,150 --> 00:11:20,470
different mechanisms of
isolation and protection.

243
00:11:20,470 --> 00:11:21,710
We talked about, for example,

244
00:11:21,710 --> 00:11:25,429
segmentation versus virtual
memory management, right?

245
00:11:25,429 --> 00:11:27,129
What are the pros and cons?

246
00:11:27,129 --> 00:11:28,789
Would you ever use
one versus the other?

247
00:11:28,789 --> 00:11:31,949
Always think about the extremes
of the continuum, right?

248
00:11:31,949 --> 00:11:36,910
X 86 and low level hardware
and protection interfaces.

249
00:11:36,910 --> 00:11:43,270
We talked about rings of
power and other things.

250
00:11:43,270 --> 00:11:46,819
In that context,
kernel organization,

251
00:11:46,819 --> 00:11:48,679
one of the questions actually

252
00:11:48,679 --> 00:11:50,299
has to do with
kernel organization,

253
00:11:50,299 --> 00:11:51,779
so we'll get back to kernel

254
00:11:51,779 --> 00:11:53,479
organization in a few minutes.

255
00:11:53,479 --> 00:11:56,399
Virtual memory management
was huge, right?

256
00:11:56,399 --> 00:11:58,960
We covered two weeks
worth of VMM material.

257
00:11:58,960 --> 00:12:00,820
So you would expect
that to be fairly well

258
00:12:00,820 --> 00:12:02,959
represented in your exam, right?

259
00:12:02,959 --> 00:12:04,879
That would be a natural
assumption to make.

260
00:12:04,879 --> 00:12:07,580
And, of course, also
reinforced by your lab, too,

261
00:12:07,580 --> 00:12:10,419
which was also a
fairly hefty fraction

262
00:12:10,419 --> 00:12:12,300
of the time you spend
between now and the exam.

263
00:12:12,300 --> 00:12:15,840
So quite natural to assume

264
00:12:15,840 --> 00:12:17,659
that this is something
that the exam is

265
00:12:17,659 --> 00:12:19,839
also going to try
to test, right?

266
00:12:19,839 --> 00:12:23,139
Concurrency and scheduling,
super important.

267
00:12:23,150 --> 00:12:25,530
And we covered that. We talked

268
00:12:25,530 --> 00:12:28,850
about the mechanisms
of concurrency.

269
00:12:28,850 --> 00:12:31,369
We talked about happens
before relationships, right?

270
00:12:31,369 --> 00:12:33,650
We talked about
database conditions.

271
00:12:33,650 --> 00:12:35,349
We talked about just in

272
00:12:35,349 --> 00:12:38,929
general race conditions and
how to avoid them, right?

273
00:12:38,929 --> 00:12:40,829
And what are the complications

274
00:12:40,829 --> 00:12:42,270
associated with avoiding them?

275
00:12:42,270 --> 00:12:44,309
What happens if you
don't do it, right?

276
00:12:44,309 --> 00:12:46,350
If you expect
sequential consistency,

277
00:12:46,350 --> 00:12:48,429
don't expect sequential
consistency if

278
00:12:48,429 --> 00:12:51,369
your code is not database
free. Remember that?

279
00:12:51,369 --> 00:12:53,569
So all of that is kind of in

280
00:12:53,569 --> 00:12:56,110
the context of what we can test.

281
00:12:56,110 --> 00:12:58,270
And of course, user
and kernel threading,

282
00:12:58,270 --> 00:13:00,269
which is something we
covered right before

283
00:13:00,269 --> 00:13:03,855
the discussion of operating
system and network.

284
00:13:03,855 --> 00:13:06,359
Okay, so let's get into it.

285
00:13:06,359 --> 00:13:11,120
Practice exam, Q one is asking
us about micro kernels.

286
00:13:11,120 --> 00:13:14,359
Microkernels provide additional
memory space isolation

287
00:13:14,359 --> 00:13:17,480
by separating not only the
kernel from user space,

288
00:13:17,480 --> 00:13:19,059
so there's this
natural separation

289
00:13:19,059 --> 00:13:20,540
between kernel and user space,

290
00:13:20,540 --> 00:13:23,159
but also subsystems within
the kernel from each other.

291
00:13:23,159 --> 00:13:24,159
So basically, you can have

292
00:13:24,159 --> 00:13:25,899
different operating
system functions

293
00:13:25,899 --> 00:13:28,839
kind of factored out as user
space processes, right?

294
00:13:28,839 --> 00:13:30,280
So the question is asking,

295
00:13:30,280 --> 00:13:31,659
what are the costs of using

296
00:13:31,659 --> 00:13:35,260
a micro kernel over
a monolithic kernel,

297
00:13:35,260 --> 00:13:37,799
and please explain
why these costs are

298
00:13:37,799 --> 00:13:42,330
fundamental to a
microkernel. So any ideas?

299
00:13:42,330 --> 00:13:45,049
This should be a fairly
straightforward question

300
00:13:45,049 --> 00:13:47,209
just to ease you in, yes.

301
00:13:47,209 --> 00:13:49,129
If you're using a microkernel,

302
00:13:49,129 --> 00:13:51,009
you'd have to do more
context switches

303
00:13:51,009 --> 00:13:52,969
to kernel space because you

304
00:13:52,969 --> 00:13:55,549
have user level processes

305
00:13:55,549 --> 00:13:58,330
doing things in a
monolithic kernel,

306
00:13:58,330 --> 00:14:00,714
you would generally
have the kernel quien.

307
00:14:00,714 --> 00:14:02,840
Yeah, so more contact switches.

308
00:14:02,840 --> 00:14:05,920
So this is one of the costs
of micro kernel is that now

309
00:14:05,920 --> 00:14:07,939
your operating
system services are

310
00:14:07,939 --> 00:14:10,060
actually kind of user
space processes,

311
00:14:10,060 --> 00:14:12,000
and you guys are doing
your lab three now.

312
00:14:12,000 --> 00:14:13,620
You've already seen
the switch function.

313
00:14:13,620 --> 00:14:14,940
You've seen the scheduler code.

314
00:14:14,940 --> 00:14:16,719
It's going to be one
of those things for

315
00:14:16,719 --> 00:14:18,839
which you need to roll
contact switch, right?

316
00:14:18,839 --> 00:14:20,539
It's no longer
part of the kernel

317
00:14:20,539 --> 00:14:22,879
proper. Anybody else? Yeah.

318
00:14:22,879 --> 00:14:26,580
Why the context
switch is expensive.

319
00:14:27,070 --> 00:14:30,309
Can we just say it's expensive?

320
00:14:31,110 --> 00:14:33,850
I mean, in this particular case,

321
00:14:33,850 --> 00:14:35,249
I think if you just say that

322
00:14:35,249 --> 00:14:36,789
it's a user space process and it

323
00:14:36,789 --> 00:14:39,929
would require more context
switches, I would take that.

324
00:14:39,929 --> 00:14:42,909
Yeah, I don't think in this
case, you need to explain it.

325
00:14:42,909 --> 00:14:46,090
Sometimes the way the question
is phrased, remember,

326
00:14:46,090 --> 00:14:48,849
we had that moment where
the context switch was

327
00:14:48,849 --> 00:14:51,590
actually a smaller overhead

328
00:14:51,590 --> 00:14:53,490
compared to some other
overhead, for instance.

329
00:14:53,490 --> 00:14:56,270
So if the question is
specifically asking,

330
00:14:56,270 --> 00:14:58,350
then you should specify.

331
00:14:58,350 --> 00:15:00,790
Okay? But this one doesn't.

332
00:15:01,120 --> 00:15:03,499
Great modularity and control of

333
00:15:03,499 --> 00:15:05,359
each individual casi perform.

334
00:15:05,359 --> 00:15:07,299
And so that's an
advantage, right?

335
00:15:07,299 --> 00:15:10,199
Okay. And the question is

336
00:15:10,199 --> 00:15:13,619
asking about costs. Yeah.
But yeah, you're right.

337
00:15:13,619 --> 00:15:15,300
If the question is also asking

338
00:15:15,300 --> 00:15:16,939
most likely about
the advantages,

339
00:15:16,939 --> 00:15:19,260
that's find that. Yeah, good.

340
00:15:19,260 --> 00:15:22,899
Anybody else? So yeah,

341
00:15:22,899 --> 00:15:24,739
basically, think about
examples, right?

342
00:15:24,739 --> 00:15:25,719
It's always good to think

343
00:15:25,719 --> 00:15:28,300
about some specific
concrete examples.

344
00:15:28,300 --> 00:15:30,499
So let's say the kernel
actually wants to

345
00:15:30,499 --> 00:15:33,439
use some file system
functionality,

346
00:15:33,439 --> 00:15:37,359
which decides that it
needs to interact with

347
00:15:37,359 --> 00:15:39,359
page cache and Pagecach

348
00:15:39,359 --> 00:15:42,120
now is trying to
touch disk service,

349
00:15:42,120 --> 00:15:45,239
and disk service is now kind
of blocking on block cache.

350
00:15:45,239 --> 00:15:47,399
And that goes back
to the file system.

351
00:15:47,399 --> 00:15:48,760
Imagine all of these context

352
00:15:48,760 --> 00:15:50,499
switches that you
have to do, right?

353
00:15:50,499 --> 00:15:52,360
And how many times you actually

354
00:15:52,360 --> 00:15:54,360
cross the kernel
userspace boundary,

355
00:15:54,360 --> 00:15:57,039
which in itself is
also quite expensive.

356
00:15:57,039 --> 00:15:59,859
So we talked about
contact switches,

357
00:15:59,859 --> 00:16:02,519
and then why are the
contact switches expensive?

358
00:16:02,519 --> 00:16:04,339
You can elaborate
on that, right?

359
00:16:04,339 --> 00:16:07,340
So what happens when
we switch context?

360
00:16:07,780 --> 00:16:11,720
Yeah. You flush the TLB

361
00:16:11,720 --> 00:16:13,299
because you're changing
something, right?

362
00:16:13,299 --> 00:16:16,479
What are you changing
on the contact switch.

363
00:16:16,479 --> 00:16:18,399
What triggers a TLB?

364
00:16:18,399 --> 00:16:19,580
Address space.

365
00:16:19,580 --> 00:16:21,539
Yeah, you're changing
address spaces, right?

366
00:16:21,539 --> 00:16:23,439
And there are all
sorts of things that

367
00:16:23,439 --> 00:16:26,319
happen when you're changing
address spaces, right?

368
00:16:26,319 --> 00:16:29,240
TLB flush is one of them.

369
00:16:29,240 --> 00:16:33,179
Okay. So that was and

370
00:16:33,179 --> 00:16:34,759
this is an example
of kind of what

371
00:16:34,759 --> 00:16:36,759
a microkernel architecture
would look like.

372
00:16:36,759 --> 00:16:40,299
So what you're looking at
is a man core architecture.

373
00:16:40,299 --> 00:16:43,000
It's sort of a two
dimensional grid of course,

374
00:16:43,000 --> 00:16:44,760
each of which is
running something,

375
00:16:44,760 --> 00:16:46,299
right? And it's color coded.

376
00:16:46,299 --> 00:16:48,500
So you have Ido cores

377
00:16:48,500 --> 00:16:50,519
are in red, so don't
worry about those.

378
00:16:50,519 --> 00:16:52,479
The blue ones are
the application

379
00:16:52,479 --> 00:16:53,780
that you actually want to run,

380
00:16:53,780 --> 00:16:55,239
and the black ones are

381
00:16:55,239 --> 00:16:57,480
the memory allocation servers

382
00:16:57,480 --> 00:16:59,899
which are now user
space processes, okay?

383
00:16:59,899 --> 00:17:03,100
And the green ones are
the file system servers,

384
00:17:03,100 --> 00:17:05,119
which are now
userspace processes.

385
00:17:05,119 --> 00:17:09,070
And so we discussed
what can possibly

386
00:17:09,070 --> 00:17:10,989
happen when you
actually try to get

387
00:17:10,989 --> 00:17:14,069
something done in this
type of architecture.

388
00:17:14,069 --> 00:17:17,109
Okay, so what benefits
does a system get

389
00:17:17,109 --> 00:17:20,249
from the isolation provided
by a micro kernel?

390
00:17:20,249 --> 00:17:22,689
So one of the advantages
that we believe

391
00:17:22,689 --> 00:17:24,169
the microkernel is giving us

392
00:17:24,169 --> 00:17:26,049
is the advantage of isolation,

393
00:17:26,049 --> 00:17:30,330
right, or failure
isolation in particular.

394
00:17:30,330 --> 00:17:34,009
So what are the
question is asking,

395
00:17:34,009 --> 00:17:35,809
What benefits do we get from

396
00:17:35,809 --> 00:17:39,110
the isolation provided by
the micro kernel? Any ideas?

397
00:17:39,110 --> 00:17:43,769
Yes. 16 compromise
the entire Yeah,

398
00:17:43,769 --> 00:17:45,090
you basically establish

399
00:17:45,090 --> 00:17:47,429
very natural security
boundaries, right?

400
00:17:47,429 --> 00:17:49,410
If one of the services
is compromised,

401
00:17:49,410 --> 00:17:51,289
that doesn't mean that the
kernel is compromised,

402
00:17:51,289 --> 00:17:55,529
for instance, right? Let's see.

403
00:17:55,529 --> 00:17:58,149
So isolation is already kind of

404
00:17:58,149 --> 00:18:00,389
naturally following
from the statement

405
00:18:00,389 --> 00:18:05,249
of the question itself,
fault protection, right?

406
00:18:05,249 --> 00:18:08,935
So that's a big
one. Anybody else?

407
00:18:08,935 --> 00:18:12,080
Can somebody elaborate
on fault protection?

408
00:18:12,080 --> 00:18:14,479
Are we getting better
fault protection? Yes.

409
00:18:14,479 --> 00:18:18,520
If one process crashes or goes
out of bounds or whatever,

410
00:18:18,520 --> 00:18:19,960
it doesn't take down
the whole kernel.

411
00:18:19,960 --> 00:18:21,999
I'll just isolate that process.

412
00:18:21,999 --> 00:18:25,119
Yeah, so one user space
process, if that crashes,

413
00:18:25,119 --> 00:18:26,639
it doesn't take down
the entire system,

414
00:18:26,639 --> 00:18:29,719
which is also the case with
the monolithic kernel, right?

415
00:18:29,719 --> 00:18:31,420
But then in this
particular case,

416
00:18:31,420 --> 00:18:33,399
what benefit do we
get specifically

417
00:18:33,399 --> 00:18:36,559
from a micro kernel that's
related to what you said?

418
00:18:38,100 --> 00:18:41,719
Yeah. Some of the what might be

419
00:18:41,719 --> 00:18:45,380
traditionally monolithic
kernel operation

420
00:18:45,380 --> 00:18:46,219
would be done as

421
00:18:46,219 --> 00:18:48,919
a user service typically from

422
00:18:48,919 --> 00:18:54,259
base kernel so that that
can detect a fault in,

423
00:18:54,259 --> 00:18:55,419
if it's a disc driver that

424
00:18:55,419 --> 00:18:57,459
fails that would
run in the kernel,

425
00:18:57,459 --> 00:18:59,920
the kernel might panic.
It panics, yeah.

426
00:18:59,920 --> 00:19:00,939
The kernel panics.

427
00:19:00,939 --> 00:19:03,019
Whereas, if it's separate,

428
00:19:03,019 --> 00:19:04,399
then the kernel could do

429
00:19:04,399 --> 00:19:06,694
something to clean
that up or restart it.

430
00:19:06,694 --> 00:19:09,469
Yeah, exactly. And basically,

431
00:19:09,469 --> 00:19:11,009
you're kind of isolating failure

432
00:19:11,009 --> 00:19:12,689
to a specific user
space process.

433
00:19:12,689 --> 00:19:13,909
And I'm pretty
sure this is where

434
00:19:13,909 --> 00:19:15,529
you were heading with
that answer, right?

435
00:19:15,529 --> 00:19:18,689
That if some of the
operating system services

436
00:19:18,689 --> 00:19:21,249
are encapsulated as
user space processes,

437
00:19:21,249 --> 00:19:24,329
their failure is not catastrophic
to the system, right?

438
00:19:24,329 --> 00:19:27,250
As you mentioned security,

439
00:19:27,250 --> 00:19:29,189
kind of, and this is where I

440
00:19:29,189 --> 00:19:32,290
like to bring in
the SPARTA analogy.

441
00:19:33,420 --> 00:19:36,259
Because a narrow
attack surface is

442
00:19:36,259 --> 00:19:39,100
always beneficial for Defense.

443
00:19:39,100 --> 00:19:41,480
Because this is Sparta.

444
00:19:41,480 --> 00:19:45,539
Do you guys know about this
famous Spartan battle,

445
00:19:45,539 --> 00:19:47,519
how they won with 300 people?

446
00:19:47,519 --> 00:19:51,179
Yeah. Oh, I go ask for

447
00:19:51,179 --> 00:19:58,759
narrow service So for
multiple reasons.

448
00:19:58,759 --> 00:20:02,119
One of them is actually that
there's less code, right?

449
00:20:02,119 --> 00:20:04,459
In a specific operating
system service,

450
00:20:04,459 --> 00:20:07,359
there's typically
kind of some kind

451
00:20:07,359 --> 00:20:10,460
of monotonically
increasing relationship

452
00:20:10,460 --> 00:20:12,320
between the number of lines

453
00:20:12,320 --> 00:20:15,619
of code that are
being affected and

454
00:20:15,619 --> 00:20:17,379
how vulnerable or the

455
00:20:17,379 --> 00:20:20,419
probability of security
violations in that code, right?

456
00:20:20,419 --> 00:20:23,454
So this is, in some sense,
related to modularity.

457
00:20:23,454 --> 00:20:25,350
But that's one answer.

458
00:20:25,350 --> 00:20:27,329
The other answer related to

459
00:20:27,329 --> 00:20:29,909
security is that as I
think he mentioned,

460
00:20:29,909 --> 00:20:32,849
if someone compromises
your user space process,

461
00:20:32,849 --> 00:20:35,569
they still don't have access
to the entire system, right?

462
00:20:35,569 --> 00:20:37,329
They've just compromised
that process.

463
00:20:37,329 --> 00:20:39,909
They don't have, for instance,

464
00:20:39,909 --> 00:20:41,650
access to the kernel space

465
00:20:41,650 --> 00:20:43,210
or anything that's
happening in the kernel.

466
00:20:43,210 --> 00:20:45,029
And therefore, they
might not have access to

467
00:20:45,029 --> 00:20:48,009
the other operating system
services running, right?

468
00:20:48,009 --> 00:20:50,889
So those are the two
answers to your question.

469
00:20:51,270 --> 00:20:53,909
Modularity, right?

470
00:20:53,909 --> 00:20:56,469
And this is sort of a software
engineering benefit that

471
00:20:56,469 --> 00:20:59,189
you get from micro kernel
is because in some sense,

472
00:20:59,189 --> 00:21:00,829
it's sort of easier to

473
00:21:00,829 --> 00:21:04,009
manage from a project
management perspective,

474
00:21:04,009 --> 00:21:06,570
it incurs less technical debt.

475
00:21:06,570 --> 00:21:09,130
And the smaller the
individual components

476
00:21:09,130 --> 00:21:11,249
are that you can deploy in your

477
00:21:11,249 --> 00:21:14,349
what now becomes sort of a
distributed operating system

478
00:21:14,349 --> 00:21:15,989
on a man core architecture.

479
00:21:15,989 --> 00:21:17,469
The smaller those
components are,

480
00:21:17,469 --> 00:21:19,189
the easier it is to
iterate on them,

481
00:21:19,189 --> 00:21:21,429
the easier it is to
upgrade them, right?

482
00:21:21,429 --> 00:21:23,610
The easier it is
to actually patch

483
00:21:23,610 --> 00:21:26,669
the security vulnerabilities
and all that good stuff.

484
00:21:26,669 --> 00:21:28,389
So there are multiple advantages

485
00:21:28,389 --> 00:21:30,429
that the micro kernel
actually provides.

486
00:21:30,429 --> 00:21:32,549
Even though it does have all of

487
00:21:32,549 --> 00:21:35,829
these disadvantages that
we started with, right?

488
00:21:35,870 --> 00:21:37,109
Yeah.

489
00:21:37,109 --> 00:21:40,430
So I talked about software
engineering perspective here.

490
00:21:40,430 --> 00:21:42,109
So it's easier to develop.

491
00:21:42,109 --> 00:21:44,910
It's easier to deploy,
easier to test.

492
00:21:45,510 --> 00:21:48,389
And so the entire kind of

493
00:21:48,389 --> 00:21:51,129
pipeline becomes
quite a bit more

494
00:21:51,129 --> 00:21:53,250
agile and you sort of incur

495
00:21:53,250 --> 00:21:56,430
less technical debt for all
of those reasons, okay?

496
00:21:56,430 --> 00:21:58,330
But the counter argument here,

497
00:21:58,330 --> 00:22:01,709
especially to the isolation

498
00:22:01,709 --> 00:22:04,989
is how much isolation do
we really get, right?

499
00:22:04,989 --> 00:22:07,549
And we discussed
this during lecture,

500
00:22:07,549 --> 00:22:09,469
because sometimes we feel like

501
00:22:09,469 --> 00:22:11,390
we're getting fault isolation,

502
00:22:11,390 --> 00:22:15,310
but this could be kind of a
false sense of isolation.

503
00:22:15,310 --> 00:22:17,869
So can somebody comment on that?

504
00:22:18,310 --> 00:22:21,709
Yes. These tend to
rely on each other.

505
00:22:21,709 --> 00:22:24,450
So if one goes down, and all
the other processes won't

506
00:22:24,450 --> 00:22:27,189
be able to execute
as yeah, exactly.

507
00:22:27,189 --> 00:22:29,509
Did everyone hear
that? So basically,

508
00:22:29,509 --> 00:22:32,969
there's a possibility
that processes have

509
00:22:32,969 --> 00:22:35,769
such an intertwined
dependency on

510
00:22:35,769 --> 00:22:39,309
the other user space
processes that a failure of,

511
00:22:39,309 --> 00:22:41,049
let's say, a file system server,

512
00:22:41,049 --> 00:22:42,749
even though it's a user space,

513
00:22:42,749 --> 00:22:45,349
it has so many dependencies,
so many tasks,

514
00:22:45,349 --> 00:22:48,369
so many other user space
processes depending on that,

515
00:22:48,369 --> 00:22:51,009
that it doesn't really
matter that we sort of

516
00:22:51,009 --> 00:22:53,649
factored it out into
user space, you know?

517
00:22:53,649 --> 00:22:56,269
And so I think I have so

518
00:22:56,269 --> 00:22:57,229
this kind of leads me to

519
00:22:57,229 --> 00:22:58,809
the discussion of
failure closure.

520
00:22:58,809 --> 00:23:01,389
So I'm going to try to get
through this fairly quickly.

521
00:23:01,389 --> 00:23:03,349
Um but this is

522
00:23:03,349 --> 00:23:05,489
the picture that we had
in the slides, right?

523
00:23:05,489 --> 00:23:06,990
On the left hand side.

524
00:23:06,990 --> 00:23:08,949
So yeah, on the left hand side,

525
00:23:08,949 --> 00:23:11,870
you have a monolithic
kernel and life is good.

526
00:23:11,870 --> 00:23:13,230
When user space processes

527
00:23:13,230 --> 00:23:15,129
are failing, it
doesn't affect it.

528
00:23:15,129 --> 00:23:16,610
On the right hand side,

529
00:23:16,610 --> 00:23:18,829
what we've tried to do
is we've tried to factor

530
00:23:18,829 --> 00:23:22,250
out these services as
user space processes.

531
00:23:22,250 --> 00:23:24,649
But our user buys, right,

532
00:23:24,649 --> 00:23:26,629
our use of buys
takes some form of

533
00:23:26,629 --> 00:23:29,509
dependency on releases services.

534
00:23:29,509 --> 00:23:31,769
So, for example, one

535
00:23:31,769 --> 00:23:34,530
could have a set of services
that it depends upon.

536
00:23:34,530 --> 00:23:36,410
You two can have a different set

537
00:23:36,410 --> 00:23:38,050
of services that
it depends upon.

538
00:23:38,050 --> 00:23:45,069
And so if any of these
Subjs basically fail,

539
00:23:45,069 --> 00:23:48,159
then this is going to
affect use of B, okay?

540
00:23:48,159 --> 00:23:51,370
But if any other SK fails that's

541
00:23:51,370 --> 00:23:54,970
not in the failure closure of
usabi then use Bi survives.

542
00:23:54,970 --> 00:23:58,950
And so that means that for any
given vertex thus defined,

543
00:23:58,950 --> 00:24:03,290
okay, we can actually construct
a failure closure set.

544
00:24:03,330 --> 00:24:06,930
Meaning that if anything
fails in that set,

545
00:24:06,930 --> 00:24:10,669
then this is going
to affect my use Bi.

546
00:24:10,669 --> 00:24:12,889
And this can be
done declaratively,

547
00:24:12,889 --> 00:24:15,609
imperatively, it's sort
of less important.

548
00:24:16,210 --> 00:24:19,589
Sort of more of a
research insight.

549
00:24:19,589 --> 00:24:21,490
And so on the right hand side,

550
00:24:21,490 --> 00:24:23,909
we know that these
are fairly sparse,

551
00:24:23,909 --> 00:24:25,869
so they can be sparse, right?

552
00:24:25,869 --> 00:24:28,009
So if you think
about this as us by

553
00:24:28,009 --> 00:24:30,469
SJ as an adjacency matrix,

554
00:24:30,469 --> 00:24:32,229
right, you can imagine

555
00:24:32,229 --> 00:24:34,329
this adjacency matrix
being fairly sparse,

556
00:24:34,329 --> 00:24:37,009
which is a good thing for
failure isolation, right?

557
00:24:37,009 --> 00:24:41,209
And so if I ask you if
an adjacency matrix

558
00:24:41,209 --> 00:24:42,509
that represents kind of

559
00:24:42,509 --> 00:24:45,449
these failure dependencies
is sparse versus dense,

560
00:24:45,449 --> 00:24:47,610
you know, how much failure
isolation we're getting,

561
00:24:47,610 --> 00:24:49,369
you should be able
to get that, right?

562
00:24:49,369 --> 00:24:52,369
Because if it's dense,
what does that mean?

563
00:24:52,400 --> 00:24:57,599
Yeah. Lots of dependencies.
And so what does that mean?

564
00:24:57,599 --> 00:25:00,380
Is not really true isolation.

565
00:25:00,380 --> 00:25:02,939
Yeah, then you're
getting fall isolation.

566
00:25:02,939 --> 00:25:05,979
Specifically, that's how
fall isolation is defined

567
00:25:05,979 --> 00:25:09,860
is when this adjacency
matrix is dense, okay?

568
00:25:09,860 --> 00:25:12,080
Alright, so what about the use

569
00:25:12,080 --> 00:25:14,239
of bites on the left hand side?

570
00:25:15,900 --> 00:25:17,939
Yeah.

571
00:25:19,740 --> 00:25:22,699
Yeah, the kernel and, you know,

572
00:25:22,699 --> 00:25:25,499
all of the services that
the kernel provides.

573
00:25:25,499 --> 00:25:27,400
So the dependency here for each

574
00:25:27,400 --> 00:25:29,420
of the user buys on
the left hand side

575
00:25:29,420 --> 00:25:31,939
is if you were to

576
00:25:31,939 --> 00:25:35,819
write it pseudo mathematically,
what would that say?

577
00:25:39,940 --> 00:25:42,299
Anyone?

578
00:25:43,540 --> 00:25:47,639
As a function of SJs.

579
00:25:47,639 --> 00:25:49,539
Yeah.

580
00:25:52,350 --> 00:25:54,430
So basically, I'm asking,

581
00:25:54,430 --> 00:25:55,710
kind of what are the user Bes

582
00:25:55,710 --> 00:25:57,149
depend on on the left hand side?

583
00:25:57,149 --> 00:25:59,089
They depend on all
the services, right?

584
00:25:59,089 --> 00:26:01,170
Because they're all
part of the kernel.

585
00:26:01,170 --> 00:26:02,770
And so if you were to write

586
00:26:02,770 --> 00:26:04,689
down the failure
closure for use,

587
00:26:04,689 --> 00:26:09,589
it would basically be a
set of all Subjs, okay?

588
00:26:09,589 --> 00:26:12,149
That's the only point that
I'm trying to make here.

589
00:26:12,149 --> 00:26:14,070
And so on the left hand side,

590
00:26:14,070 --> 00:26:16,449
all user space
processes depend on

591
00:26:16,449 --> 00:26:19,429
all I'm calling them
usabes here, okay?

592
00:26:19,429 --> 00:26:21,170
Depend on all Subjs

593
00:26:21,170 --> 00:26:22,650
because they already
part of the kernel,

594
00:26:22,650 --> 00:26:24,549
and everybody depends
on the kernel.

595
00:26:24,549 --> 00:26:26,770
You have no choice with
monolithic kernel.

596
00:26:26,770 --> 00:26:28,669
So if you were to represent this

597
00:26:28,669 --> 00:26:32,029
as an adjacency matrix,
what would it look like?

598
00:26:34,870 --> 00:26:37,390
Say it again.

599
00:26:38,080 --> 00:26:41,219
Huh? Very dense. Very dense.

600
00:26:41,219 --> 00:26:42,899
I mean, more concretely,

601
00:26:42,899 --> 00:26:47,299
it would be a matrix
of once, right?

602
00:26:47,299 --> 00:26:49,180
It would be a matrix of ones,

603
00:26:49,180 --> 00:26:51,239
and that's the important thing.

604
00:26:51,240 --> 00:26:54,039
Because usabtes go vertically,

605
00:26:54,039 --> 00:26:55,779
Subjs go horizontally, for

606
00:26:55,779 --> 00:26:58,040
each usabte depends on all Subj.

607
00:26:58,040 --> 00:26:59,500
So it's a row of ones,

608
00:26:59,500 --> 00:27:01,600
another row of ones,
another row of ones.

609
00:27:01,600 --> 00:27:04,939
So you get a matrix of
one, okay? Super dense.

610
00:27:04,939 --> 00:27:07,819
And now you can start
to reason, you know,

611
00:27:07,819 --> 00:27:10,259
about the density of
this adjacency matrix

612
00:27:10,259 --> 00:27:12,360
and what that means in terms

613
00:27:12,360 --> 00:27:14,159
of whether you get

614
00:27:14,159 --> 00:27:17,400
isolation or you get
fall isolation, okay?

615
00:27:17,400 --> 00:27:21,619
Alright. Now, C is asking

616
00:27:21,619 --> 00:27:24,699
one concrete use case where we

617
00:27:24,699 --> 00:27:28,879
still want the micro kernel
over a monolithic kernel.

618
00:27:29,080 --> 00:27:31,839
Oh, sorry, where
the advantages of

619
00:27:31,839 --> 00:27:33,519
a micro kernel over monolithic

620
00:27:33,519 --> 00:27:35,459
would not benefit
the overall system.

621
00:27:35,459 --> 00:27:38,160
So what are some of the examples

622
00:27:38,800 --> 00:27:43,700
where we would still want
a micro kernel? Yeah.

623
00:27:43,700 --> 00:27:46,500
About a code that means
a lot of privileges.

624
00:27:46,500 --> 00:27:49,559
It's just better
to stay in time.

625
00:27:49,880 --> 00:27:52,999
Okay, so you're sort of claiming

626
00:27:52,999 --> 00:27:56,359
that fall isolation is the
reason for this, right?

627
00:27:56,400 --> 00:28:00,359
Okay. Okay. Any others?

628
00:28:00,400 --> 00:28:12,120
Yeah. Tolerant. Mm hmm.

629
00:28:12,980 --> 00:28:15,979
So basically a trusted
environment, right?

630
00:28:15,979 --> 00:28:18,820
So basically, if we don't
have to worry about security,

631
00:28:18,820 --> 00:28:22,159
for instance, which maybe
sometimes happens, right,

632
00:28:22,159 --> 00:28:25,199
if there's an air gap
system, which I mean,

633
00:28:25,199 --> 00:28:26,719
we just had a
security lecture that

634
00:28:26,719 --> 00:28:29,119
air gap system can
still be broken, right?

635
00:28:29,119 --> 00:28:31,079
Because something
was installed on

636
00:28:31,079 --> 00:28:34,779
an Iranian nuclear power
plant via US Bistik, right?

637
00:28:34,779 --> 00:28:37,439
So air gap systems are
not necessarily secure.

638
00:28:37,439 --> 00:28:39,259
But anyway, let's take it.

639
00:28:39,259 --> 00:28:41,279
Somebody thought
that air gap systems

640
00:28:41,279 --> 00:28:43,059
are secure and it's a
trusted environment,

641
00:28:43,059 --> 00:28:44,639
so you may not
necessarily want to

642
00:28:44,639 --> 00:28:48,439
have a micro kernel
overhead, right?

643
00:28:48,439 --> 00:28:50,139
Any other reasons why we

644
00:28:50,139 --> 00:28:51,839
would want to have
a micro kernel?

645
00:28:51,839 --> 00:28:53,599
It's sort of how

646
00:28:53,599 --> 00:28:55,399
to approach this question
in general, right?

647
00:28:55,399 --> 00:28:58,099
You might think, how do I
even approach this question?

648
00:28:58,099 --> 00:28:59,920
We'll start thinking
about the advantages

649
00:28:59,920 --> 00:29:01,900
of micro kernel that
we've just discussed,

650
00:29:01,900 --> 00:29:03,819
and we usually
build this up over

651
00:29:03,819 --> 00:29:06,260
the several sub questions
like what are the advantages?

652
00:29:06,260 --> 00:29:08,640
What are the disadvantages?
What are the trade offs?

653
00:29:08,640 --> 00:29:10,919
And then here's a specific
use case or give me

654
00:29:10,919 --> 00:29:12,059
a specific use case that

655
00:29:12,059 --> 00:29:13,339
would benefit from
one or the other.

656
00:29:13,339 --> 00:29:15,454
That's a typical
structure of a question.

657
00:29:15,454 --> 00:29:20,169
Yeah. Yeah, performance
critical, right?

658
00:29:20,169 --> 00:29:23,250
Something that and
more concretely, yes,

659
00:29:23,250 --> 00:29:24,789
you might want the
performance here,

660
00:29:24,789 --> 00:29:26,490
but you might also
want predictability.

661
00:29:26,490 --> 00:29:28,769
Maybe it's a real time
operating system, right?

662
00:29:28,769 --> 00:29:30,550
And all of these
context switches,

663
00:29:30,550 --> 00:29:33,250
you know, how does that
affect predictability?

664
00:29:33,250 --> 00:29:36,349
Pretty bad, right, because
you all of a sudden kind of

665
00:29:36,349 --> 00:29:39,370
lose control because you
have to go back and forth,

666
00:29:39,370 --> 00:29:41,450
back and forth between
the different contexts,

667
00:29:41,450 --> 00:29:42,609
and you don't really know what

668
00:29:42,609 --> 00:29:44,469
the schedule is doing or in

669
00:29:44,469 --> 00:29:46,229
what order it's actually
going to schedule

670
00:29:46,229 --> 00:29:48,669
my operating system
services, right?

671
00:29:48,669 --> 00:29:51,449
You may or may not know.
The bottom line is that

672
00:29:51,449 --> 00:29:54,630
it probabilistically
lowers predictability.

673
00:29:54,630 --> 00:29:57,389
Um situations where you

674
00:29:57,389 --> 00:29:59,609
want tight control over what's
happening in the system,

675
00:29:59,609 --> 00:30:01,470
which is related
to predictability.

676
00:30:01,470 --> 00:30:04,690
Other examples including
better microcontrollers,

677
00:30:04,690 --> 00:30:07,050
situations where you have
a trusted environment

678
00:30:07,050 --> 00:30:09,609
or an air gapped
environment, right?

679
00:30:09,609 --> 00:30:12,409
And, you know, those
are the use cases that

680
00:30:12,409 --> 00:30:14,550
would benefit from
micro kernel advantages

681
00:30:14,550 --> 00:30:19,029
that we have discussed,
okay? All right.

682
00:30:19,029 --> 00:30:20,649
Any other questions
about ir quarter?

683
00:30:20,649 --> 00:30:22,850
Shall we move on
to third quarter?

684
00:30:23,690 --> 00:30:27,009
We still have five
more questions to go.

685
00:30:27,009 --> 00:30:29,849
And let's say 30 minutes.

686
00:30:30,250 --> 00:30:33,689
All right, let's go with
cuter. We have a friend.

687
00:30:33,689 --> 00:30:36,249
His name is Harry, and he's very

688
00:30:36,249 --> 00:30:39,209
concerned about the
isolation on his system.

689
00:30:39,209 --> 00:30:40,929
And so he wishes to provide

690
00:30:40,929 --> 00:30:43,490
a perfect CPU isolation
between processes.

691
00:30:43,490 --> 00:30:45,509
So this is a question
about isolation,

692
00:30:45,509 --> 00:30:47,225
right? And what that means.

693
00:30:47,225 --> 00:30:49,300
More specifically,
right? We're trying

694
00:30:49,300 --> 00:30:50,859
to define what we mean by

695
00:30:50,859 --> 00:30:54,939
isolation perfect by perfect
isolation between processes.

696
00:30:54,939 --> 00:30:58,819
He wants to guarantee that
a given process cannot

697
00:30:58,819 --> 00:31:01,240
determine how many
other processes

698
00:31:01,240 --> 00:31:03,680
are running based on its
own CPU utilization.

699
00:31:03,680 --> 00:31:05,299
In other words, if I run,

700
00:31:05,299 --> 00:31:06,939
I really want to feel like

701
00:31:06,939 --> 00:31:08,379
I'm the only one in the system.

702
00:31:08,379 --> 00:31:10,359
And we started talking about

703
00:31:10,359 --> 00:31:12,859
this from the first week
in this class, right?

704
00:31:12,859 --> 00:31:15,020
That's kind of like
the perfect isolation.

705
00:31:15,020 --> 00:31:17,060
I really want to feel

706
00:31:17,060 --> 00:31:19,959
like nobody else is in the
system other than myself.

707
00:31:19,959 --> 00:31:22,459
And so what Harry
wants is that he

708
00:31:22,459 --> 00:31:25,179
doesn't want the process
to have the ability to

709
00:31:25,179 --> 00:31:27,679
determine how many other
processes are running based on

710
00:31:27,679 --> 00:31:30,459
its own CPU consumption.

711
00:31:30,459 --> 00:31:33,779
And he's asking you about
your opinion and doing so.

712
00:31:33,779 --> 00:31:36,380
And the question is, I'm
going to skip the assumption.

713
00:31:36,380 --> 00:31:38,499
That's fairly obvious.
The question is,

714
00:31:38,499 --> 00:31:40,119
please explain how perfect

715
00:31:40,119 --> 00:31:42,280
CPU isolation between processes,

716
00:31:42,280 --> 00:31:44,519
how is that incompatible with

717
00:31:44,519 --> 00:31:46,259
an operating system abstraction

718
00:31:46,259 --> 00:31:48,459
of having infinite
processes available?

719
00:31:48,459 --> 00:31:50,725
What's the incompatibility here?

720
00:31:50,725 --> 00:31:55,610
Yes. It's kind of
like it's the idea

721
00:31:55,610 --> 00:31:57,709
that if you want every
single process going

722
00:31:57,709 --> 00:32:00,689
back to the dependency vectors,

723
00:32:00,689 --> 00:32:02,989
what you want is you
want every single one of

724
00:32:02,989 --> 00:32:06,429
those dependency vectors to
have the only instance of

725
00:32:06,429 --> 00:32:09,129
that dependency belonging
to that process

726
00:32:09,129 --> 00:32:11,329
so that no other process

727
00:32:11,329 --> 00:32:13,209
can fail if that one
dependency goes down,

728
00:32:13,209 --> 00:32:16,909
which means every single
process that on I don't know,

729
00:32:16,909 --> 00:32:19,509
like a file system term and to

730
00:32:19,509 --> 00:32:22,369
have its own version of
a file system service.

731
00:32:22,369 --> 00:32:25,169
Okay, so we're done talking
about micro kernel.

732
00:32:25,169 --> 00:32:28,629
This is just an abstract
question about in general,

733
00:32:28,629 --> 00:32:30,710
an operating system
and its ability

734
00:32:30,710 --> 00:32:33,250
to provide the
perfect isolation.

735
00:32:33,250 --> 00:32:36,829
So, you know, try to swap
out the context that has to

736
00:32:36,829 --> 00:32:40,469
do with dependencies between
different processes.

737
00:32:40,469 --> 00:32:44,969
So is there some other
reason why, you know,

738
00:32:44,969 --> 00:32:49,250
the achieving perfect
CPU isolation

739
00:32:49,250 --> 00:32:51,409
can be incompatible with

740
00:32:51,409 --> 00:32:55,029
our abstraction of having
infinite processes. Yes.

741
00:32:55,029 --> 00:32:58,469
Well, the whole point of
infinite processes is that we

742
00:32:58,469 --> 00:33:01,469
have to multiplex the
infinite processes on,

743
00:33:01,469 --> 00:33:02,829
like, you know, a
limited number of

744
00:33:02,829 --> 00:33:04,489
Cs. Yeah, yeah, exactly.

745
00:33:04,489 --> 00:33:06,849
I really, really large number
of processes and only,

746
00:33:06,849 --> 00:33:08,170
like, you know, a handful Cs.

747
00:33:08,170 --> 00:33:09,529
It's like,

748
00:33:09,529 --> 00:33:11,569
inevitably, we're going to
have to be swapping out,

749
00:33:11,569 --> 00:33:13,569
and the process
could detect that.

750
00:33:13,569 --> 00:33:17,329
Like it CPU usage would change,
so it could detect that.

751
00:33:17,329 --> 00:33:19,569
Yeah, exactly. So basically,

752
00:33:19,569 --> 00:33:22,010
if you do have an infinite
number of processes,

753
00:33:22,010 --> 00:33:24,549
imagine, you know, what is
going to be the quantum

754
00:33:24,549 --> 00:33:26,010
of time that you
should be allocating

755
00:33:26,010 --> 00:33:28,169
to that process, right?

756
00:33:28,450 --> 00:33:33,189
It's finitely large T

757
00:33:33,189 --> 00:33:36,569
divided by infinitely
many processes M,

758
00:33:36,569 --> 00:33:38,629
and if you take
the limit of that,

759
00:33:38,629 --> 00:33:41,250
you're going to get a zero.

760
00:33:42,090 --> 00:33:44,770
Okay? And so no matter

761
00:33:44,770 --> 00:33:48,769
what scheduling policy
you employ here,

762
00:33:48,769 --> 00:33:51,229
it doesn't really
matter because over

763
00:33:51,229 --> 00:33:55,109
a sufficiently large
amount of time you know,

764
00:33:55,109 --> 00:33:56,630
if you want to be
able to provide

765
00:33:56,630 --> 00:33:59,130
support for infinitely
many processes,

766
00:33:59,130 --> 00:34:01,789
you have the expectation of

767
00:34:01,789 --> 00:34:04,470
the time allocated to
any given processes,

768
00:34:04,470 --> 00:34:05,669
T divided by N with

769
00:34:05,669 --> 00:34:08,969
a limit N approaches infinity
is going to be zero.

770
00:34:08,969 --> 00:34:11,929
And so we achieve the
impossibility result.

771
00:34:11,929 --> 00:34:15,809
We're not system is not
going to function if we're

772
00:34:15,809 --> 00:34:17,849
allocating zero quantum of

773
00:34:17,849 --> 00:34:20,349
time to each of the
processes, right?

774
00:34:20,349 --> 00:34:23,204
So that makes it incompatible.

775
00:34:23,204 --> 00:34:27,240
Okay? And so if that
doesn't make sense,

776
00:34:27,240 --> 00:34:30,379
yet hold that thought
because it will

777
00:34:30,379 --> 00:34:31,619
become more clear when we

778
00:34:31,619 --> 00:34:34,319
discuss the other subquestions
of this question.

779
00:34:34,319 --> 00:34:37,699
Because here, Harry
was convinced all of a

780
00:34:37,699 --> 00:34:39,339
sudden that it is impossible

781
00:34:39,339 --> 00:34:41,580
to achieve perfect isolation.

782
00:34:41,580 --> 00:34:44,540
And by the way, let's
make it more concrete.

783
00:34:44,540 --> 00:34:46,199
It sounded super
abstract, right?

784
00:34:46,199 --> 00:34:47,679
Alright, some people don't

785
00:34:47,679 --> 00:34:49,380
like things that
are super abstract,

786
00:34:49,380 --> 00:34:50,939
take a fork test, which is

787
00:34:50,939 --> 00:34:53,499
a very famous Linux
benchmark, right?

788
00:34:53,499 --> 00:34:55,759
And what happens to
the performance of

789
00:34:55,759 --> 00:34:57,140
fork test when you increase

790
00:34:57,140 --> 00:34:59,580
the number of processes
you are forking?

791
00:34:59,580 --> 00:35:04,200
Does it stay the same?
No? What happens?

792
00:35:04,440 --> 00:35:09,959
What? The performance is
starting to go down, right?

793
00:35:09,959 --> 00:35:12,119
And the reason for
this is because as

794
00:35:12,119 --> 00:35:14,480
the number of processes
in the system increases,

795
00:35:14,480 --> 00:35:17,459
you know, inevitably the
system starts to slow down.

796
00:35:17,459 --> 00:35:18,379
And so, of course,

797
00:35:18,379 --> 00:35:20,139
each individual process
will be able to

798
00:35:20,139 --> 00:35:23,160
notice that kind of based
on how much progress

799
00:35:23,160 --> 00:35:26,459
that application or that
process is able to make

800
00:35:26,459 --> 00:35:31,415
over some period of
fixed time, okay?

801
00:35:31,415 --> 00:35:33,649
So that's another way
to think about it

802
00:35:33,649 --> 00:35:35,450
as the number of
processes increases,

803
00:35:35,450 --> 00:35:37,389
kind of the perception of

804
00:35:37,389 --> 00:35:39,950
progress that each
individual process

805
00:35:39,950 --> 00:35:44,189
has changes and gets

806
00:35:44,189 --> 00:35:46,934
worse and worse as you increase
the number of processes.

807
00:35:46,934 --> 00:35:49,720
Alright, so let's say that
we've convinced Harry,

808
00:35:49,720 --> 00:35:51,860
and we can come back to that
if you have any questions.

809
00:35:51,860 --> 00:35:53,539
I just want to get through this.

810
00:35:53,539 --> 00:35:55,759
He's willing to provide
an upper bound.

811
00:35:55,759 --> 00:35:57,019
You know, he says, Okay, fine.

812
00:35:57,019 --> 00:35:59,080
If the infinity is not possible,

813
00:35:59,080 --> 00:36:00,479
let's put an upper bound.

814
00:36:00,479 --> 00:36:03,680
In other words, from the
perspective of the system,

815
00:36:03,680 --> 00:36:05,560
we are going to do
admission control

816
00:36:05,560 --> 00:36:07,539
on the number of
processes we can have.

817
00:36:07,539 --> 00:36:12,684
And we know that the upper
limit is N, constant N, okay?

818
00:36:12,684 --> 00:36:15,450
So how might Harry leverage

819
00:36:15,450 --> 00:36:18,529
this fact to allocate
processes CPU time in

820
00:36:18,529 --> 00:36:20,969
a way that does not leak

821
00:36:20,969 --> 00:36:23,149
any information
about the number of

822
00:36:23,149 --> 00:36:25,289
processes running
in the system? Yes.

823
00:36:25,289 --> 00:36:27,690
So you can use round
ramen scheduler

824
00:36:27,690 --> 00:36:30,949
then always pretend that
they're in processes running.

825
00:36:30,949 --> 00:36:33,529
So each process is going
to have the same amount of

826
00:36:33,529 --> 00:36:34,749
scheduler time regardless of

827
00:36:34,749 --> 00:36:36,529
how many processes
are actually running.

828
00:36:36,529 --> 00:36:39,230
Yeah. Yeah. Exactly.
So basically,

829
00:36:39,230 --> 00:36:42,469
you can kind of
allocate slots, right?

830
00:36:42,469 --> 00:36:45,589
And they're going to occupy
a finite amount of time,

831
00:36:45,589 --> 00:36:48,549
so no infinity business
here anymore, right?

832
00:36:48,549 --> 00:36:53,050
Allocate slots, and you have
a maximum of end resources,

833
00:36:53,050 --> 00:36:55,829
and you basically
say that slot zero,

834
00:36:55,829 --> 00:36:57,329
process zero is going to run.

835
00:36:57,329 --> 00:36:59,189
Slot one, process
one is going to run.

836
00:36:59,189 --> 00:37:00,629
And if there's no process one,

837
00:37:00,629 --> 00:37:06,239
nothing runs. Okay?
Nothing runs.

838
00:37:06,239 --> 00:37:08,219
But from the perspective of

839
00:37:08,219 --> 00:37:10,559
any given process
that is running,

840
00:37:10,559 --> 00:37:13,699
they always get the same
allocation of time,

841
00:37:13,699 --> 00:37:17,894
and they always make the
same progress over time.

842
00:37:17,894 --> 00:37:22,469
And so no information
about the existence or

843
00:37:22,469 --> 00:37:25,289
the count of other tenants in

844
00:37:25,289 --> 00:37:28,470
the system is ever leaking
to any given process.

845
00:37:28,470 --> 00:37:31,250
And so this allows us
to achieve isolation.

846
00:37:31,250 --> 00:37:33,450
This is the kind of
perfect isolation

847
00:37:33,450 --> 00:37:35,269
that we want, but in
order to achieve it,

848
00:37:35,269 --> 00:37:37,689
we have to break
the abstraction of

849
00:37:37,689 --> 00:37:39,090
infinite number of resources

850
00:37:39,090 --> 00:37:41,669
supported by the system. Yes.

851
00:37:41,669 --> 00:37:45,869
Using a pod scheduler
also work out.

852
00:37:45,869 --> 00:37:48,609
Well, any scheduler would work.

853
00:37:48,609 --> 00:37:50,709
Because remember,
we're talking about

854
00:37:50,709 --> 00:37:53,549
sufficiently large
amount of time T,

855
00:37:53,549 --> 00:37:58,110
if you uh the five F scheduler

856
00:37:58,110 --> 00:38:00,349
would the five F
scheduler work, hold on.

857
00:38:00,349 --> 00:38:02,350
What do you mean by
the FFO scheduler?

858
00:38:02,350 --> 00:38:05,229
Like, I just like

859
00:38:05,229 --> 00:38:06,829
what are you looking for us

860
00:38:06,829 --> 00:38:08,289
to specifically
say this question?

861
00:38:08,289 --> 00:38:10,389
We have to explain, like,

862
00:38:10,389 --> 00:38:12,809
how, how this would work,

863
00:38:12,809 --> 00:38:15,850
I guess, in terms of,
using a scheduling?

864
00:38:15,850 --> 00:38:17,929
Well, concretely kind of

865
00:38:17,929 --> 00:38:19,189
describe what you would

866
00:38:19,189 --> 00:38:21,230
do from a scheduler's
perspective.

867
00:38:21,230 --> 00:38:24,189
So the round robin answer
was actually a spot on,

868
00:38:24,189 --> 00:38:27,769
where you would divide
time into Quanta,

869
00:38:27,769 --> 00:38:30,229
and you would allocate Quanta

870
00:38:30,229 --> 00:38:33,830
to the set of runable processes.

871
00:38:34,190 --> 00:38:38,890
Okay. And so the set of
basically you have slots,

872
00:38:38,890 --> 00:38:40,429
zero through minus one.

873
00:38:40,429 --> 00:38:41,790
When you admit a process,

874
00:38:41,790 --> 00:38:45,249
it gets this process ID
from zero to N minus one.

875
00:38:45,249 --> 00:38:47,009
So that's the way the
system would work.

876
00:38:47,009 --> 00:38:48,209
You'd have to describe how

877
00:38:48,209 --> 00:38:50,189
the system works in
order to achieve this.

878
00:38:50,189 --> 00:38:55,429
So you get slots that you
have N possible process ID,

879
00:38:55,429 --> 00:38:56,629
zero through N minus one.

880
00:38:56,629 --> 00:38:58,989
When you admit them, they
get that process ID.

881
00:38:58,989 --> 00:39:01,129
And the way the
scheduler would have

882
00:39:01,129 --> 00:39:03,749
to execute is that it

883
00:39:03,749 --> 00:39:05,189
would perform some sort of

884
00:39:05,189 --> 00:39:08,749
Round Robin scheduling
where now slot zero runs,

885
00:39:08,749 --> 00:39:09,929
now slot one runs,

886
00:39:09,929 --> 00:39:11,330
now slot two runs.

887
00:39:11,330 --> 00:39:12,950
And if there's a process

888
00:39:12,950 --> 00:39:14,549
that matches the
number of the slot,

889
00:39:14,549 --> 00:39:16,509
that process only would run.

890
00:39:16,509 --> 00:39:19,069
If there's no process,
nothing runs.

891
00:39:19,069 --> 00:39:20,789
So I take that back.

892
00:39:20,789 --> 00:39:23,369
The FIFO scheduler
would not work here.

893
00:39:23,369 --> 00:39:25,489
Because the FIFO scheduler would

894
00:39:25,489 --> 00:39:27,309
leak the amount of
information, right?

895
00:39:27,309 --> 00:39:29,050
Because if you have
two processes,

896
00:39:29,050 --> 00:39:30,469
the FIFO scheduler would do one,

897
00:39:30,469 --> 00:39:33,149
two, one, two, one,
two, one, two, right?

898
00:39:33,990 --> 00:39:37,010
Yes. When you
allocate end slots,

899
00:39:37,010 --> 00:39:38,829
let's say there's
not end processes.

900
00:39:38,829 --> 00:39:40,349
It's like an empty slot,

901
00:39:40,349 --> 00:39:42,910
you just sleep or you
just don't execute.

902
00:39:42,910 --> 00:39:44,509
You basically do nothing.

903
00:39:44,509 --> 00:39:47,090
Yeah. You don't
execute any process.

904
00:39:47,090 --> 00:39:49,450
Maybe there's a dummy
process that you execute.

905
00:39:49,450 --> 00:39:58,949
You sleep. Well,
that's exactly right.

906
00:39:58,949 --> 00:40:01,329
It wouldn't. And that's

907
00:40:01,329 --> 00:40:03,409
what we're trying
to achieve, right?

908
00:40:03,409 --> 00:40:05,710
So any process that actually

909
00:40:05,710 --> 00:40:08,089
does get one ninth of that time,

910
00:40:08,089 --> 00:40:10,569
right, it always gets
one ninth of the time.

911
00:40:10,569 --> 00:40:12,590
So let me try to
advance the slides.

912
00:40:12,590 --> 00:40:14,070
Maybe this will help explain.

913
00:40:14,070 --> 00:40:15,909
If you think about
the amount of time

914
00:40:15,909 --> 00:40:18,170
that's allocated to
a specific process,

915
00:40:18,170 --> 00:40:19,869
the fundamental
question you should be

916
00:40:19,869 --> 00:40:22,190
asking is whether or
not it's a functional.

917
00:40:22,190 --> 00:40:23,949
In this particular
case, it would

918
00:40:23,949 --> 00:40:26,710
not be a function of
N. It's constant.

919
00:40:27,080 --> 00:40:30,159
Right? Because you always
get the same amount of time.

920
00:40:30,159 --> 00:40:32,139
Let's say ten milliseconds.

921
00:40:32,139 --> 00:40:34,320
It doesn't matter

922
00:40:34,320 --> 00:40:37,280
how many processes there
are in the system.

923
00:40:37,280 --> 00:40:39,039
If it does depend on

924
00:40:39,039 --> 00:40:41,020
the number of processes
that are in the system,

925
00:40:41,020 --> 00:40:42,319
then you have a
problem, then you're

926
00:40:42,319 --> 00:40:44,379
leaking the
information about it.

927
00:40:44,379 --> 00:40:46,419
And then is it a constant or

928
00:40:46,419 --> 00:40:48,099
a variable function of M, right?

929
00:40:48,099 --> 00:40:50,660
So that sort of determines
whether or not you're leaking

930
00:40:50,660 --> 00:40:54,439
information about other
processes in the system. Okay.

931
00:40:54,680 --> 00:40:58,039
We're still question
two. What are

932
00:40:58,039 --> 00:40:59,640
the inefficiencies
in this design?

933
00:40:59,640 --> 00:41:02,879
I think that should be
obvious, right? So yeah.

934
00:41:03,560 --> 00:41:07,119
Yeah, you end up
wasting time when you

935
00:41:07,119 --> 00:41:10,299
allocate those slots to non
existent processes, right?

936
00:41:10,299 --> 00:41:12,559
And again, trade off, right?

937
00:41:12,559 --> 00:41:14,200
If you want perfect isolation,

938
00:41:14,200 --> 00:41:15,579
you have to pay
something for it.

939
00:41:15,579 --> 00:41:17,459
And what you're paying
is the inefficiency

940
00:41:17,459 --> 00:41:19,680
in the system, but
you can achieve.

941
00:41:19,740 --> 00:41:23,819
Okay. So yeah, the problem
here is that if there are

942
00:41:23,819 --> 00:41:27,399
fewer than the constant
N number of processes,

943
00:41:27,399 --> 00:41:30,680
right, then you're
inefficiently using the system.

944
00:41:30,680 --> 00:41:32,499
You're literally just
sleeping, right?

945
00:41:32,499 --> 00:41:35,079
The resource utilization
is going to depend on

946
00:41:35,079 --> 00:41:37,320
however many processes
or what fraction

947
00:41:37,320 --> 00:41:40,040
of N number of processes
you have in the system.

948
00:41:40,040 --> 00:41:42,659
Any other questions about this?

949
00:41:45,630 --> 00:41:48,829
Okay, let's move on
to question three.

950
00:41:48,829 --> 00:41:51,529
This is the one where
we're kind of asked to

951
00:41:51,529 --> 00:41:55,009
construct a new 32
bit CPU architecture,

952
00:41:55,009 --> 00:41:56,669
and we're considering making

953
00:41:56,669 --> 00:41:59,490
the virtual memory page
size on this architecture.

954
00:41:59,490 --> 00:42:02,429
30 bytes, okay? 32 bytes.

955
00:42:02,429 --> 00:42:03,509
So remember that number,

956
00:42:03,509 --> 00:42:05,370
32 bytes because
that's important,

957
00:42:05,370 --> 00:42:07,709
which of course is
much smaller than

958
00:42:07,709 --> 00:42:10,709
four K page four kilobyte
page that you're

959
00:42:10,709 --> 00:42:12,489
all used to from 2,200

960
00:42:12,489 --> 00:42:14,509
from this class, from
wherever, right?

961
00:42:14,509 --> 00:42:17,170
Due to the power of 12 bytes.

962
00:42:17,170 --> 00:42:19,629
And so the first
question is asking,

963
00:42:19,629 --> 00:42:21,150
would you expect a kernel

964
00:42:21,150 --> 00:42:23,529
running on top of Robert's
architecture to be

965
00:42:23,529 --> 00:42:26,090
more or less memory efficient

966
00:42:26,090 --> 00:42:30,069
than a classic four
kilobyte page architecture?

967
00:42:33,710 --> 00:42:37,629
Pool, people know how to
approach this question.

968
00:42:37,629 --> 00:42:42,469
Let's ask someone I haven't
asked yet. Yeah, maybe you.

969
00:42:52,990 --> 00:42:55,349
Mm hmm.

970
00:42:55,349 --> 00:42:59,549
Okay, so basically your
argument is that for

971
00:42:59,549 --> 00:43:01,229
very small processes that are

972
00:43:01,229 --> 00:43:02,749
only very small in

973
00:43:02,749 --> 00:43:04,709
terms of their memory
footprint, right,

974
00:43:04,709 --> 00:43:08,070
the code data stack and heap
and all that good stuff,

975
00:43:08,070 --> 00:43:11,709
you don't need to waste
the memory resources in

976
00:43:11,709 --> 00:43:15,509
order to allocate finer
granularity pages, right?

977
00:43:15,509 --> 00:43:16,789
And so you're arguing that it's

978
00:43:16,789 --> 00:43:18,169
going to be more
efficient, right?

979
00:43:18,169 --> 00:43:20,169
So that's one side
of the argument.

980
00:43:20,169 --> 00:43:22,410
Now, let's see if there's
another side of the argument.

981
00:43:22,410 --> 00:43:22,894
Yes.

982
00:43:22,894 --> 00:43:24,279
I

983
00:43:35,200 --> 00:43:36,679
A lot more

984
00:43:36,679 --> 00:43:38,419
of the page table pages, right?

985
00:43:38,419 --> 00:43:43,275
Okay. Okay. Yes. Anybody
else? Yes, in the middle.

986
00:43:43,275 --> 00:43:45,649
I was thinking too
along that line,

987
00:43:45,649 --> 00:43:48,869
you want to have the same
amount of memory, like,

988
00:43:48,869 --> 00:43:51,389
given to like that
a process with

989
00:43:51,389 --> 00:43:53,009
four kilobyte pages
could have or

990
00:43:53,009 --> 00:43:55,209
like a system four
kilobyte pages could have.

991
00:43:55,209 --> 00:43:58,289
You're going to need
way more, you're

992
00:43:58,289 --> 00:44:00,029
going to need way more
storage for all that.

993
00:44:00,029 --> 00:44:01,509
Like, you're going to
need more entries in

994
00:44:01,509 --> 00:44:04,130
your page directory and more
entries in your page tables.

995
00:44:04,130 --> 00:44:06,109
Yeah. So remember,
it's asking about

996
00:44:06,109 --> 00:44:08,430
memory efficiency
or memory overhead.

997
00:44:08,430 --> 00:44:10,429
So think about what
that means, right?

998
00:44:10,429 --> 00:44:13,309
And in general, how do you
approach this question?

999
00:44:13,309 --> 00:44:17,169
So, uh let's see.

1000
00:44:17,169 --> 00:44:20,149
How do I have
anything useful here?

1001
00:44:20,149 --> 00:44:22,689
Okay, yes, how do you
approach this problem, right?

1002
00:44:22,689 --> 00:44:24,589
You have to analyze
first of all,

1003
00:44:24,589 --> 00:44:26,090
you have to start with analyzing

1004
00:44:26,090 --> 00:44:27,690
the linear address breakdown

1005
00:44:27,690 --> 00:44:29,129
because once you start there,

1006
00:44:29,129 --> 00:44:31,370
it already gives you quite
a bit of information.

1007
00:44:31,370 --> 00:44:34,009
So we have a 32
bit system, right?

1008
00:44:34,009 --> 00:44:36,110
We have a 32 bit system.

1009
00:44:36,110 --> 00:44:41,570
And we said that our pages
are going to be 32 bytes.

1010
00:44:41,570 --> 00:44:45,009
So How many bits do we need
for the page offset in

1011
00:44:45,009 --> 00:44:50,075
order in order to address
into a 32 byte page.

1012
00:44:50,075 --> 00:44:57,839
Yeah. No. Five,
what? How many bits?

1013
00:44:57,839 --> 00:45:01,260
Five bits, you need five bits.

1014
00:45:01,260 --> 00:45:05,239
So five bits, the least
significant five bits of

1015
00:45:05,239 --> 00:45:08,359
your 32 bit linear
address are going to be

1016
00:45:08,359 --> 00:45:13,140
addressing into
your 32 byte page.

1017
00:45:13,140 --> 00:45:16,139
That's fine. And
how much is left?

1018
00:45:16,139 --> 00:45:19,119
27, 27 plus five.

1019
00:45:19,119 --> 00:45:22,680
Yeah, 27 bits are
going to be your PFM,

1020
00:45:22,680 --> 00:45:25,230
your physical frame
number. Or VfN.

1021
00:45:25,230 --> 00:45:28,589
So V PFM, depending on what
we're talking about here.

1022
00:45:28,589 --> 00:45:31,890
Of course, in the linear
address, it will be a VN.

1023
00:45:31,890 --> 00:45:34,509
So that's a good
starting point, right?

1024
00:45:34,509 --> 00:45:37,190
We are using five bits
for the page offset.

1025
00:45:37,190 --> 00:45:40,730
We're using 27 bits
for the PFN and VFN.

1026
00:45:40,730 --> 00:45:43,089
So what is going to
be the PTE size?

1027
00:45:43,089 --> 00:45:46,449
So we know how much
this page is, right?

1028
00:45:46,449 --> 00:45:49,689
We know how many bits we're
using to address into it.

1029
00:45:49,689 --> 00:45:51,409
And now let's start
thinking about

1030
00:45:51,409 --> 00:45:53,489
the last level page table page.

1031
00:45:53,489 --> 00:45:55,069
This is a page table page.

1032
00:45:55,069 --> 00:45:58,810
It consists of page
table entries, PTs.

1033
00:45:58,810 --> 00:46:03,330
First of all, how wide are
the PTs on this system?

1034
00:46:04,500 --> 00:46:08,180
Yeah, there are four bytes
because it's a 32 bit system.

1035
00:46:08,180 --> 00:46:10,959
Remember, when we
switched 32-64,

1036
00:46:10,959 --> 00:46:13,839
our PTs also became
64 bits, right?

1037
00:46:13,839 --> 00:46:15,279
So whatever the system is,

1038
00:46:15,279 --> 00:46:17,960
that's going to be the
size of your PTE always.

1039
00:46:17,960 --> 00:46:21,059
So our PTs are
four bytes, right?

1040
00:46:21,059 --> 00:46:26,439
Okay, let's say four bytes
or 32 bits, 32 bits.

1041
00:46:26,439 --> 00:46:29,119
And so for every at

1042
00:46:29,119 --> 00:46:30,779
what granularity are we

1043
00:46:30,779 --> 00:46:34,060
addressing physical
frames of memory?

1044
00:46:34,180 --> 00:46:37,319
In other words, how
many PTEs does it

1045
00:46:37,319 --> 00:46:40,740
take for us to address a
single frame of memory?

1046
00:46:41,640 --> 00:46:46,520
Zero, one, 0.52 100.

1047
00:46:46,520 --> 00:46:49,640
One. It takes exactly one PTE

1048
00:46:49,640 --> 00:46:51,860
to address a physical
frame of memory.

1049
00:46:51,860 --> 00:46:53,519
So let's say we have a PTE right

1050
00:46:53,519 --> 00:46:56,300
here that I should
be more careful,

1051
00:46:56,300 --> 00:46:57,719
that addresses the base of

1052
00:46:57,719 --> 00:46:59,819
this physical frame
of memory, right?

1053
00:46:59,819 --> 00:47:02,560
And this PTE is four bytes.

1054
00:47:02,560 --> 00:47:05,419
This page is 32 bytes, right?

1055
00:47:05,419 --> 00:47:08,750
So you're paying the
overhead of four bytes.

1056
00:47:08,750 --> 00:47:12,199
Divided by 32 bytes, right?

1057
00:47:12,199 --> 00:47:16,540
So one eighth, which
is approximately 12.5%

1058
00:47:16,540 --> 00:47:17,759
overhead in order to

1059
00:47:17,759 --> 00:47:22,060
address the 32 byte
granularity pages.

1060
00:47:22,060 --> 00:47:25,059
Now, how does that compare
with four kilobyte page?

1061
00:47:25,059 --> 00:47:28,379
Four kilobyte, it changes
the denominator here.

1062
00:47:28,379 --> 00:47:29,980
On a 32 bit system,

1063
00:47:29,980 --> 00:47:32,639
your numerator is still
four bytes because

1064
00:47:32,639 --> 00:47:36,099
the size of the
PTE, so size here.

1065
00:47:36,099 --> 00:47:38,060
Here, this is the formula,

1066
00:47:38,060 --> 00:47:42,240
size of PTE under squat, okay,

1067
00:47:42,240 --> 00:47:49,619
divided by the size of
the physical frame.

1068
00:47:52,780 --> 00:47:57,739
Basically, for a typical system
where our size of PTE was

1069
00:47:57,739 --> 00:48:00,300
four bytes and the
size of the page

1070
00:48:00,300 --> 00:48:03,529
was 4 kilobytes, right?

1071
00:48:03,529 --> 00:48:07,039
I don't know. It's going to
be something much better.

1072
00:48:07,039 --> 00:48:10,499
1/1000, something, 1/1024,

1073
00:48:10,499 --> 00:48:12,880
a much smaller overhead

1074
00:48:12,880 --> 00:48:15,700
associated with addressing
a single frame of memory.

1075
00:48:15,700 --> 00:48:18,419
And we need one PT
per page, right?

1076
00:48:18,419 --> 00:48:20,839
You cannot get around that.
So even though you do get

1077
00:48:20,839 --> 00:48:23,819
the benefit for very,

1078
00:48:23,819 --> 00:48:26,399
very small processes
that might only use

1079
00:48:26,399 --> 00:48:29,379
64 bytes of memory,
overall, right,

1080
00:48:29,379 --> 00:48:31,100
for regular sized processes,

1081
00:48:31,100 --> 00:48:32,919
you're paying a
lot of overhead in

1082
00:48:32,919 --> 00:48:35,340
order to address
into 32 byte pages.

1083
00:48:35,340 --> 00:48:39,889
Does that make sense? As
a matter of fact, it's,

1084
00:48:39,889 --> 00:48:42,010
you know, approximately 12.5%,

1085
00:48:42,010 --> 00:48:45,409
and we're only counting
last level pages here.

1086
00:48:47,000 --> 00:48:50,939
This is actually a lower
bound. It's higher than that.

1087
00:48:50,939 --> 00:48:53,659
I could ask a question for
why it's higher than that.

1088
00:48:53,659 --> 00:48:56,320
Because these PTs do
not exist in isolation.

1089
00:48:56,320 --> 00:48:59,599
They exist as part of a page
table page and you need to

1090
00:48:59,599 --> 00:49:01,700
allocate the entire
page table page

1091
00:49:01,700 --> 00:49:03,360
in order to hold these PTs.

1092
00:49:03,360 --> 00:49:05,380
So the amount of memory overhead

1093
00:49:05,380 --> 00:49:07,580
you have is actually
strictly higher

1094
00:49:07,580 --> 00:49:10,459
than the sum of
the sizes of APTs

1095
00:49:10,459 --> 00:49:12,279
require you require in

1096
00:49:12,279 --> 00:49:14,020
order to address your
physical frames.

1097
00:49:14,020 --> 00:49:17,779
Does that make sense?
So think of this

1098
00:49:17,779 --> 00:49:20,099
as essentially the sum of

1099
00:49:20,099 --> 00:49:23,259
all the size of PTEPs
that's a lower bound,

1100
00:49:23,259 --> 00:49:24,859
again, because they're held by

1101
00:49:24,859 --> 00:49:28,155
page table pages that you
also need to allocate.

1102
00:49:28,155 --> 00:49:31,650
Makes sense? So for instance,

1103
00:49:31,650 --> 00:49:33,429
what the hell did
I just say, right?

1104
00:49:33,429 --> 00:49:35,889
For instance, if there's
a single PT here that

1105
00:49:35,889 --> 00:49:38,449
you need to address
into your, let's say,

1106
00:49:38,449 --> 00:49:42,429
your code segment, second PT

1107
00:49:42,429 --> 00:49:44,630
that you need to address
into your data segment

1108
00:49:44,630 --> 00:49:46,629
and you don't need
anything else.

1109
00:49:46,629 --> 00:49:48,209
Like, to his point,

1110
00:49:48,209 --> 00:49:50,089
if this is actually a very,

1111
00:49:50,089 --> 00:49:52,629
very small process, right,

1112
00:49:52,629 --> 00:49:55,070
even though you're
only using two PTs,

1113
00:49:55,070 --> 00:49:56,630
you are going to allocate

1114
00:49:56,630 --> 00:50:00,610
a huge page for the
PFN for the PTP,

1115
00:50:00,610 --> 00:50:03,230
the page table page in
order to hold those PTs.

1116
00:50:03,230 --> 00:50:04,769
Anyway, that's what I meant by

1117
00:50:04,769 --> 00:50:06,754
the fact that this
is a lower bound.

1118
00:50:06,754 --> 00:50:10,180
Divided by the sum of the
sizes of the physical frames.

1119
00:50:10,180 --> 00:50:12,340
So this is essentially a formula

1120
00:50:12,340 --> 00:50:15,359
for determining what the memory
overhead is going to be.

1121
00:50:15,359 --> 00:50:16,900
At the lower bound

1122
00:50:16,900 --> 00:50:19,199
on the memory overhead,
this is going to be.

1123
00:50:19,199 --> 00:50:21,400
I should be more precise.

1124
00:50:21,400 --> 00:50:32,729
Okay. Yes. That's correct. Yeah.

1125
00:50:32,729 --> 00:50:35,149
The size of a PT is always

1126
00:50:35,149 --> 00:50:37,029
going to be whatever
architecture you're building.

1127
00:50:37,029 --> 00:50:38,910
If it's a 16 bit architecture,

1128
00:50:38,910 --> 00:50:41,649
and I ask you questions
about 16 bit architecture,

1129
00:50:41,649 --> 00:50:44,650
the size of your PT is
going to be 16 bits.

1130
00:50:44,650 --> 00:50:47,969
Okay? And I may

1131
00:50:47,969 --> 00:50:50,829
even ask questions about an
eight bit architecture. Yeah.

1132
00:50:50,829 --> 00:50:54,049
You have to say that since
each page is so small,

1133
00:50:54,049 --> 00:50:55,529
you're going to have
many, many pages.

1134
00:50:55,529 --> 00:50:57,870
So that means we also
need to have lots

1135
00:50:57,870 --> 00:51:02,089
of PDEs and page dictor that as.

1136
00:51:02,150 --> 00:51:06,109
Oh, I guess it's already deal.

1137
00:51:06,109 --> 00:51:08,809
Yeah. Yeah, I said that
this is a lower bound,

1138
00:51:08,809 --> 00:51:11,809
and then there's
going to be some

1139
00:51:11,809 --> 00:51:13,409
more overhead on
top of that that

1140
00:51:13,409 --> 00:51:15,849
we can also quantify.
You're right.

1141
00:51:15,849 --> 00:51:18,630
But then it sort of
depends on the details

1142
00:51:18,630 --> 00:51:21,370
like do I want a one
level paging system?

1143
00:51:21,370 --> 00:51:23,569
Do I want a two level
paging system, right?

1144
00:51:23,569 --> 00:51:26,410
Because if it's a one
level paging system,

1145
00:51:26,410 --> 00:51:29,390
this is going to have some
additional additive component

1146
00:51:29,390 --> 00:51:30,730
here that's going
to be different

1147
00:51:30,730 --> 00:51:32,170
from a two level paging system.

1148
00:51:32,170 --> 00:51:34,030
So I need to give
you more information

1149
00:51:34,030 --> 00:51:36,410
to quantify that
kind of overhead.

1150
00:51:36,410 --> 00:51:39,709
And we're not given this
information in this question.

1151
00:51:39,910 --> 00:51:46,269
Okay, um Wow.

1152
00:51:46,269 --> 00:51:48,949
This is an easier one,
much easier, right?

1153
00:51:48,949 --> 00:51:52,389
So you have Robert wants

1154
00:51:52,389 --> 00:51:53,790
his hardware to have a robust

1155
00:51:53,790 --> 00:51:56,270
tracking and permission system,

1156
00:51:56,270 --> 00:51:59,710
and the permission bits that
he wants is for reading,

1157
00:51:59,710 --> 00:52:02,389
writing, user super user,

1158
00:52:02,389 --> 00:52:05,850
so that's zero, one, a control
bid to disable hardware

1159
00:52:05,850 --> 00:52:08,390
caching and some
hardware monitoring bits

1160
00:52:08,390 --> 00:52:10,490
for accessed and dirty.

1161
00:52:10,490 --> 00:52:13,069
So how many bits does he want?

1162
00:52:13,069 --> 00:52:17,909
Six. So what's the
problem with that?

1163
00:52:21,100 --> 00:52:24,739
Can we support it six
permission bits in

1164
00:52:24,739 --> 00:52:28,299
this system thus
designed? Why not?

1165
00:52:28,299 --> 00:52:38,400
Yeah. Yeah, remember,

1166
00:52:38,400 --> 00:52:40,420
that's where I started by always

1167
00:52:40,420 --> 00:52:42,360
start with the breakdown
of linear address.

1168
00:52:42,360 --> 00:52:44,119
This should be number
one step that you

1169
00:52:44,119 --> 00:52:46,219
should always do
because now it gives

1170
00:52:46,219 --> 00:52:53,400
us ready to go information
that we have 27 bits for VFNR?

1171
00:52:53,400 --> 00:52:55,739
And then we only have five
bits for permission bits,

1172
00:52:55,739 --> 00:52:59,279
and Harry Robert 16, right?

1173
00:52:59,279 --> 00:53:01,019
This cannot happen. We don't

1174
00:53:01,019 --> 00:53:03,259
have enough bits
for that, right?

1175
00:53:03,259 --> 00:53:06,099
So we cannot support it.

1176
00:53:08,710 --> 00:53:11,849
Okay. The next question is,

1177
00:53:11,849 --> 00:53:13,809
so we already at 2:52.

1178
00:53:13,809 --> 00:53:15,689
Is there a specific
question you'd rather

1179
00:53:15,689 --> 00:53:18,749
me jump to or do you
want to go in order?

1180
00:53:19,430 --> 00:53:22,369
Is there some sort of a
preference between four,

1181
00:53:22,369 --> 00:53:24,749
five and six that you
want to prioritize,

1182
00:53:24,749 --> 00:53:27,549
especially in case
you have to leave?

1183
00:53:28,310 --> 00:53:36,570
You want to do four? I
want people. Get excited.

1184
00:53:36,570 --> 00:53:39,710
Like every single time I do
the midterm practice exam,

1185
00:53:39,710 --> 00:53:42,260
I always get really excited.

1186
00:53:42,260 --> 00:53:45,130
Because it's very different
from a lot of the questions

1187
00:53:45,130 --> 00:53:47,549
you used to get in
previous classes, right?

1188
00:53:47,549 --> 00:53:49,249
It sort of makes you
think. It makes you

1189
00:53:49,249 --> 00:53:51,709
apply your knowledge
in non intuitive ways.

1190
00:53:51,709 --> 00:53:55,450
Okay, so question four is
asking for the following.

1191
00:53:55,450 --> 00:53:57,649
We have modern architectures.

1192
00:53:57,649 --> 00:53:59,569
They have a third
protection bit,

1193
00:53:59,569 --> 00:54:01,969
specifically the
execute bit, right?

1194
00:54:01,969 --> 00:54:03,849
And this bit determines if

1195
00:54:03,849 --> 00:54:05,309
the virtual address space can be

1196
00:54:05,309 --> 00:54:07,450
used to execute from a code.

1197
00:54:07,450 --> 00:54:09,410
And so we just had
a security lecture

1198
00:54:09,410 --> 00:54:11,409
where you were overwriting
the stack, right?

1199
00:54:11,409 --> 00:54:12,910
And do you remember
what happened

1200
00:54:12,910 --> 00:54:14,289
on the stack when we did a stir

1201
00:54:14,289 --> 00:54:18,649
copy with an arbitrary buffer
taken from R V, right?

1202
00:54:18,649 --> 00:54:21,849
R V one? What happened there?

1203
00:54:22,660 --> 00:54:26,119
We overrode the
EIP and then what?

1204
00:54:26,119 --> 00:54:29,979
What can we make
this EIP point to?

1205
00:54:30,260 --> 00:54:32,119
Milicious code.

1206
00:54:32,119 --> 00:54:34,219
Malicious code, where is that?

1207
00:54:34,219 --> 00:54:37,160
That malicious code
is code, data,

1208
00:54:37,160 --> 00:54:40,459
heap, stack, stack, right?

1209
00:54:40,459 --> 00:54:43,059
And so the only way this
attack will work is if we can

1210
00:54:43,059 --> 00:54:46,259
actually execute code
on stack, right?

1211
00:54:46,259 --> 00:54:50,240
And so, please give and explain

1212
00:54:50,240 --> 00:54:52,100
what advantage there
may be for marking

1213
00:54:52,100 --> 00:54:54,799
Xpix userspace stack
as non executable.

1214
00:54:54,799 --> 00:54:56,739
I think I just gave
it to you, right?

1215
00:54:56,739 --> 00:54:59,020
So what's the advantage?

1216
00:54:59,730 --> 00:55:04,250
If we went with Mike's
stackoverflow example,

1217
00:55:04,250 --> 00:55:08,049
would you be able to mount
a stackoverflow attack if

1218
00:55:08,049 --> 00:55:13,009
you have the X bit set to zero?

1219
00:55:13,290 --> 00:55:19,729
Yes or no? No, why not? Yeah.

1220
00:55:20,060 --> 00:55:23,419
Yeah, because you cannot execute
anything on users stack.

1221
00:55:23,419 --> 00:55:25,999
It's protected with the X
Bit set to zero, right?

1222
00:55:25,999 --> 00:55:27,859
So that's an easy one, right?

1223
00:55:27,859 --> 00:55:32,419
So security, stack overflow,
let's go to the next one.

1224
00:55:32,419 --> 00:55:34,899
Imagine you wanted
to modify X six.

1225
00:55:34,899 --> 00:55:37,699
Okay, now we're asking
about XV six to set

1226
00:55:37,699 --> 00:55:41,000
the execute bit on the user
space binary code space,

1227
00:55:41,000 --> 00:55:44,780
but clear it for the
binary data space, okay?

1228
00:55:44,780 --> 00:55:49,339
So, what would you have to
do what would you have to

1229
00:55:49,339 --> 00:55:51,480
change about the exact call

1230
00:55:51,480 --> 00:55:54,599
in order to make this
work within XV six?

1231
00:55:54,599 --> 00:55:56,419
Yeah.

1232
00:55:56,620 --> 00:56:03,119
Am specific functions
or for example, you,

1233
00:56:03,119 --> 00:56:05,740
you might just modify BM

1234
00:56:05,740 --> 00:56:10,039
to accept different
blacks or square,

1235
00:56:10,039 --> 00:56:12,959
it's like it's asking to sort of

1236
00:56:12,959 --> 00:56:15,900
give a description a
high level description

1237
00:56:15,900 --> 00:56:17,219
of what changes to the code

1238
00:56:17,219 --> 00:56:18,700
you would have to make without

1239
00:56:18,700 --> 00:56:20,099
actually writing code or

1240
00:56:20,099 --> 00:56:22,099
referring to specific
functions, right?

1241
00:56:22,099 --> 00:56:25,339
So it's a bit higher
level question, yes.

1242
00:56:25,339 --> 00:56:27,940
Exactly when you allocate
first few pages,

1243
00:56:27,940 --> 00:56:29,439
when you allocate
the first page,

1244
00:56:29,439 --> 00:56:32,239
you have to set to execute
it, you have to turn it on.

1245
00:56:32,239 --> 00:56:34,080
Is that's where the
instructions are stored?

1246
00:56:34,080 --> 00:56:37,199
Mm hmm. Then you turn it
off for all the other.

1247
00:56:37,199 --> 00:56:40,164
Okay, but what
happens right now?

1248
00:56:40,164 --> 00:56:43,429
Well, right now,
it doesn't set the

1249
00:56:43,429 --> 00:56:47,510
critical where's the
code and data allocated?

1250
00:56:47,510 --> 00:56:48,869
Are they allocated on the same

1251
00:56:48,869 --> 00:56:51,070
frame or in different frames?

1252
00:56:51,500 --> 00:56:53,599
Yeah. Right now,

1253
00:56:53,599 --> 00:56:55,559
the code and static data
are in the same page.

1254
00:56:55,559 --> 00:56:56,759
Or they could be
in the same page.

1255
00:56:56,759 --> 00:56:58,299
So we need to in the same page.

1256
00:56:58,299 --> 00:57:00,359
I know that the code isn't
in a different page,

1257
00:57:00,359 --> 00:57:01,999
and static data isn't
a different page,

1258
00:57:01,999 --> 00:57:03,440
and then we only have to execute

1259
00:57:03,440 --> 00:57:05,199
permissions on the code page.

1260
00:57:05,199 --> 00:57:07,179
Right. Does everyone get that?

1261
00:57:07,179 --> 00:57:09,800
So there's a possibility
that your code and data

1262
00:57:09,800 --> 00:57:13,559
today in Xp six can actually
be in the same page.

1263
00:57:13,559 --> 00:57:15,620
Now, at what granularity
do we control

1264
00:57:15,620 --> 00:57:18,140
permissions on the
physical frames of memory?

1265
00:57:18,140 --> 00:57:20,660
That granularity
is a single page.

1266
00:57:20,660 --> 00:57:22,759
If we want to set
our permissions

1267
00:57:22,759 --> 00:57:25,680
differently for different pages,

1268
00:57:25,680 --> 00:57:29,360
naturally, you want your
code to go into one page

1269
00:57:29,360 --> 00:57:33,499
and your data to go
into a separate right?

1270
00:57:33,499 --> 00:57:35,759
And so that's a thing number

1271
00:57:35,759 --> 00:57:37,640
one you want to do in your exac.

1272
00:57:37,640 --> 00:57:39,499
Without really talking about

1273
00:57:39,499 --> 00:57:42,299
specific code or functions
that you would call,

1274
00:57:42,299 --> 00:57:45,679
you should be able to provide
a description of this.

1275
00:57:45,679 --> 00:57:48,319
And the second thing
you want to do is

1276
00:57:48,319 --> 00:57:50,199
you actually want to sort of set

1277
00:57:50,199 --> 00:57:51,960
the X permission bit and reset

1278
00:57:51,960 --> 00:57:53,639
the X permission bit in one case

1279
00:57:53,639 --> 00:57:56,120
versus the other. It
has to be different.

1280
00:57:56,120 --> 00:57:59,939
So one for code
and zero for data.

1281
00:58:00,120 --> 00:58:03,579
So how do you approach
this question, right?

1282
00:58:03,579 --> 00:58:05,459
If you're completely
lost, right?

1283
00:58:05,459 --> 00:58:06,959
You know, the way
to think about it

1284
00:58:06,959 --> 00:58:08,300
is where do I get started?

1285
00:58:08,300 --> 00:58:10,599
You know, how do I start
thinking about this question?

1286
00:58:10,599 --> 00:58:13,180
You know, you should
start by asking yourself,

1287
00:58:13,180 --> 00:58:15,499
Okay, the question is
asking about code and data.

1288
00:58:15,499 --> 00:58:17,819
Where is code and data, right?

1289
00:58:17,819 --> 00:58:20,319
Where are they located in
the virtual address space.

1290
00:58:20,319 --> 00:58:23,079
You have to kind of have an
idea of where things are

1291
00:58:23,079 --> 00:58:24,879
in your virtual address space

1292
00:58:24,879 --> 00:58:27,079
before you even start
answering this question.

1293
00:58:27,079 --> 00:58:29,199
If you don't know that, there's

1294
00:58:29,199 --> 00:58:30,854
no way you can answer
this question.

1295
00:58:30,854 --> 00:58:32,869
So that's your
starting point, right?

1296
00:58:32,869 --> 00:58:34,669
And then what is the granularity

1297
00:58:34,669 --> 00:58:36,630
of the page table
protection mechanism?

1298
00:58:36,630 --> 00:58:38,749
What does that mean? It
sounds fancy, right?

1299
00:58:38,749 --> 00:58:42,149
If you don't get the
question, raise your hand.

1300
00:58:43,350 --> 00:58:47,229
Really? Okay,
that's fine, right?

1301
00:58:47,229 --> 00:58:48,729
That's fine if you
don't get the question.

1302
00:58:48,729 --> 00:58:50,750
The question is really asking.

1303
00:58:50,750 --> 00:58:53,029
I provided the answer
for you, right?

1304
00:58:53,029 --> 00:58:55,110
When you set your
permission flags,

1305
00:58:55,110 --> 00:58:57,590
how much and what
memory do they protect?

1306
00:58:57,590 --> 00:59:01,109
That's what the question
is asking, right?

1307
00:59:01,940 --> 00:59:05,439
And so at what granularity
do the PTE flex work?

1308
00:59:05,439 --> 00:59:07,779
They protect a single
physical frame, right?

1309
00:59:07,779 --> 00:59:10,439
And so what's the
next logical step?

1310
00:59:10,439 --> 00:59:11,819
The next logical step is

1311
00:59:11,819 --> 00:59:13,760
combine the two
observations above,

1312
00:59:13,760 --> 00:59:15,759
and so that's how you
arrive at the answer

1313
00:59:15,759 --> 00:59:18,140
that you need to put them
into separate frames,

1314
00:59:18,140 --> 00:59:20,540
and need to control because
you need to control

1315
00:59:20,540 --> 00:59:23,780
them with two separate
sets of permission bits.

1316
00:59:23,780 --> 00:59:26,739
And the permission bits
will have to be set

1317
00:59:26,739 --> 00:59:29,899
differently depending on
whether or not it's codo data.

1318
00:59:29,899 --> 00:59:31,900
And that sort of
implies the code,

1319
00:59:31,900 --> 00:59:35,435
you actually have to go
and write in the exact.

1320
00:59:35,435 --> 00:59:38,350
That becomes an
implementation detail

1321
00:59:38,350 --> 00:59:40,629
that to some extent is sort of,

1322
00:59:40,629 --> 00:59:42,829
you know, formulaic
at this point, right?

1323
00:59:42,829 --> 00:59:45,150
But that's the part that
you need to understand.

1324
00:59:45,150 --> 00:59:48,829
Yes. Aren't I might be
understanding exact rounds,

1325
00:59:48,829 --> 00:59:54,829
but aren't the coded dated
pages already separated? Six?

1326
00:59:54,829 --> 00:59:57,849
Well, they can end
up in the same page.

1327
00:59:57,849 --> 01:00:00,449
So somebody said that they
can end up in the same page.

1328
01:00:00,449 --> 01:00:02,839
It is possible. So you

1329
01:00:02,839 --> 01:00:04,960
just have to make sure
that it doesn't happen.

1330
01:00:04,960 --> 01:00:08,500
If that is the code,
larger 4 kilobytes.

1331
01:00:08,500 --> 01:00:11,259
What does that happen in
the case for the code

1332
01:00:11,259 --> 01:00:14,700
is larger than 4 kilobytes
or it is happening.

1333
01:00:14,700 --> 01:00:18,180
Okay, so if the code is
larger than 4 kilobytes,

1334
01:00:18,180 --> 01:00:22,399
let's say it's 6 kilobytes
and the data is 2 kilobytes,

1335
01:00:22,399 --> 01:00:25,339
can the code and data
still be on the same page?

1336
01:00:25,339 --> 01:00:29,559
Does it matter how large
your code and data are?

1337
01:00:31,180 --> 01:00:34,639
Only if you actually
explicitly allocate them at

1338
01:00:34,639 --> 01:00:36,200
page granularity and separate

1339
01:00:36,200 --> 01:00:38,160
them out into two
separate frames,

1340
01:00:38,160 --> 01:00:41,179
will you actually
ensure that there's

1341
01:00:41,179 --> 01:00:43,879
no sharing of physical
frame between

1342
01:00:43,879 --> 01:00:47,259
code segment and data
seg? Makes sense?

1343
01:00:47,259 --> 01:00:47,699
Yeah.

1344
01:00:47,699 --> 01:00:50,739
Okay. So no matter
how big they are,

1345
01:00:50,739 --> 01:00:52,960
if you don't do
something specific,

1346
01:00:52,960 --> 01:00:55,479
you may end up with

1347
01:00:55,479 --> 01:00:58,379
one frame that actually
shares code and data.

1348
01:00:58,379 --> 01:01:00,340
And then you cannot control

1349
01:01:00,340 --> 01:01:02,219
the code and data
in a single frame

1350
01:01:02,219 --> 01:01:03,999
differently because they have

1351
01:01:03,999 --> 01:01:07,179
one PTE pointing to it with
one set of permission bits.

1352
01:01:07,179 --> 01:01:11,900
Everyone got that? Okay. Um

1353
01:01:12,820 --> 01:01:15,239
Oh. What are we doing here?

1354
01:01:15,239 --> 01:01:17,740
Okay. Jesus. So basically,

1355
01:01:17,740 --> 01:01:20,519
we've been building a disc
swapping algorithm, right?

1356
01:01:20,519 --> 01:01:23,099
And I actually already
covered this in the lecture.

1357
01:01:23,099 --> 01:01:24,840
So let's go through
this quickly.

1358
01:01:24,840 --> 01:01:29,499
We had this finite state
automaton with trying to ask,

1359
01:01:29,499 --> 01:01:32,379
at what point and what are
the mechanisms given to us to

1360
01:01:32,379 --> 01:01:35,859
be able to set the access
bit zero back to one.

1361
01:01:35,859 --> 01:01:38,459
So the architecture you're
building in the system has

1362
01:01:38,459 --> 01:01:40,600
a very primitive
hardware paging system.

1363
01:01:40,600 --> 01:01:41,740
You know, how primitive?

1364
01:01:41,740 --> 01:01:45,269
What does that mean? The
only mechanism we have.

1365
01:01:45,269 --> 01:01:46,969
So the only permission bit we

1366
01:01:46,969 --> 01:01:49,749
have paging system is
a present bit, right?

1367
01:01:49,749 --> 01:01:51,629
We do not have a write bit,

1368
01:01:51,629 --> 01:01:53,950
so all pages are writable,

1369
01:01:53,950 --> 01:01:56,370
and there's no automatic
hardware tracking

1370
01:01:56,370 --> 01:01:58,470
of page accesses or writes.

1371
01:01:58,470 --> 01:02:01,229
Wow. So all you get
is a present bit.

1372
01:02:01,229 --> 01:02:05,410
Go and implement this
page swapping algorithm.

1373
01:02:06,740 --> 01:02:10,979
So the architecture does
not have an access bit.

1374
01:02:10,979 --> 01:02:13,120
Although you need to track

1375
01:02:13,120 --> 01:02:15,320
the access state to
manage a clock algorithm,

1376
01:02:15,320 --> 01:02:17,619
so you are tracking
access state logically in

1377
01:02:17,619 --> 01:02:20,519
a data structure as we discussed
in that lecture, right?

1378
01:02:20,519 --> 01:02:22,939
So please explain how
you can efficiently

1379
01:02:22,939 --> 01:02:25,825
track the access state
using the page system.

1380
01:02:25,825 --> 01:02:28,730
Okay. So remember the
clocking algorithm.

1381
01:02:28,730 --> 01:02:31,429
The clocking algorithm gets
triggered when you ran out of

1382
01:02:31,429 --> 01:02:32,810
space and you want to evict

1383
01:02:32,810 --> 01:02:35,169
the page in order to put
in a new page, right?

1384
01:02:35,169 --> 01:02:38,090
So it starts going
around the clock.

1385
01:02:38,090 --> 01:02:45,169
And the axis bit if the axis
if access is set to one,

1386
01:02:45,169 --> 01:02:46,969
you set it back to zero,

1387
01:02:46,969 --> 01:02:50,749
and you proceed to the
next vertex in this,

1388
01:02:51,320 --> 01:02:53,700
in the circular queue.

1389
01:02:53,700 --> 01:02:55,959
Now, as soon as it finds zero,

1390
01:02:55,959 --> 01:02:58,699
it's going to basically
swap out this frame two,

1391
01:02:58,699 --> 01:03:00,299
and it's going to
swap in the frame

1392
01:03:00,299 --> 01:03:02,279
five that you're
trying to put in.

1393
01:03:02,279 --> 01:03:04,679
And the axis bit is set to one.

1394
01:03:04,679 --> 01:03:07,659
So that's just a
refresher reminder of

1395
01:03:07,659 --> 01:03:11,599
how the clock algorithm
is working, right?

1396
01:03:13,160 --> 01:03:15,619
Okay, so now we have frame

1397
01:03:15,619 --> 01:03:17,799
five and we swapped
out frame two.

1398
01:03:17,799 --> 01:03:19,959
So given this clock algo,

1399
01:03:19,959 --> 01:03:23,279
when do I need to trap
on the page read?

1400
01:03:29,500 --> 01:03:32,039
When do I need a
notification that

1401
01:03:32,039 --> 01:03:35,299
a process has access
to page, Yeah.

1402
01:03:37,190 --> 01:03:39,529
Your access bit.

1403
01:03:39,529 --> 01:03:42,609
With zero with access
equal to zero,

1404
01:03:42,609 --> 01:03:43,769
let's call it that because we

1405
01:03:43,769 --> 01:03:45,309
don't have the zero access bit.

1406
01:03:45,309 --> 01:03:47,689
But very good, right?
We need a trap

1407
01:03:47,689 --> 01:03:50,249
when access is zero, okay?

1408
01:03:50,249 --> 01:03:52,609
And so if you remember back

1409
01:03:52,609 --> 01:03:54,970
to that lecture that I had
on the clock algorithm,

1410
01:03:54,970 --> 01:03:57,370
make sure you go back
and watch this, okay?

1411
01:03:57,370 --> 01:03:59,069
And I'm going to remind you of

1412
01:03:59,069 --> 01:04:01,209
the very important
finite state automaton

1413
01:04:01,209 --> 01:04:02,590
that I drew during that lecture.

1414
01:04:02,590 --> 01:04:04,369
Nobody else does it, by the way.

1415
01:04:04,369 --> 01:04:07,110
But it's very important to
understand what's happening.

1416
01:04:07,110 --> 01:04:10,809
You have two states for
the axis bit zero and one.

1417
01:04:10,809 --> 01:04:13,929
This is a very simple
finite state automaton.

1418
01:04:13,929 --> 01:04:17,309
Remember that the
most inefficient but

1419
01:04:17,350 --> 01:04:20,369
perform the most
inefficient way to

1420
01:04:20,369 --> 01:04:22,769
do this is to just set
O present bis to zero,

1421
01:04:22,769 --> 01:04:24,249
take a trap every single time

1422
01:04:24,249 --> 01:04:26,189
on every single read and write.

1423
01:04:26,189 --> 01:04:29,250
This would work, but
it's a very bad design,

1424
01:04:29,250 --> 01:04:31,149
but that's your baseline, right?

1425
01:04:31,149 --> 01:04:33,350
So what do we want instead?

1426
01:04:33,350 --> 01:04:35,995
How do we want to improve
on this baseline?

1427
01:04:35,995 --> 01:04:38,119
We want most of the reads and

1428
01:04:38,119 --> 01:04:41,619
writes to actually not give
us a page fault, right?

1429
01:04:41,619 --> 01:04:44,379
That's what we want.
How do we achieve this?

1430
01:04:44,379 --> 01:04:47,659
So remember this
finite state automaton

1431
01:04:47,659 --> 01:04:49,339
is for the accessed bit.

1432
01:04:49,339 --> 01:04:51,939
This is specifically
for the access bit.

1433
01:04:51,939 --> 01:04:55,180
Access bit sorry,
accessed variable.

1434
01:04:55,180 --> 01:04:56,519
We do not have a bit in

1435
01:04:56,519 --> 01:04:58,740
this architecture,
accessed variable.

1436
01:04:58,740 --> 01:05:02,079
So access variable can
either be zero or one.

1437
01:05:02,079 --> 01:05:04,659
So what are the state
transitions that we

1438
01:05:04,659 --> 01:05:07,519
have in this finite state
automaton? Here's one.

1439
01:05:07,519 --> 01:05:10,239
This is the most desirable one.

1440
01:05:10,990 --> 01:05:13,389
Because it's set to one,

1441
01:05:13,389 --> 01:05:15,029
we're performing
a read or write,

1442
01:05:15,029 --> 01:05:16,569
so we're accessing a page.

1443
01:05:16,569 --> 01:05:18,129
It's still set to one,

1444
01:05:18,129 --> 01:05:20,010
no page trap is happening.

1445
01:05:20,010 --> 01:05:21,809
The read and write goes through.

1446
01:05:21,809 --> 01:05:25,069
So this is what this edge
is corresponding to, right?

1447
01:05:25,069 --> 01:05:27,669
Now remember, I told
you that there's

1448
01:05:27,669 --> 01:05:31,350
a second transition
from one back to zero.

1449
01:05:33,230 --> 01:05:36,629
Who is doing that transition?

1450
01:05:37,920 --> 01:05:40,419
Yes, clock algorithm, and

1451
01:05:40,419 --> 01:05:44,539
clock algorithm is
already running where?

1452
01:05:44,539 --> 01:05:47,179
Running on a trap
handler, right?

1453
01:05:47,179 --> 01:05:49,519
So that's not the
mechanism that we can

1454
01:05:49,519 --> 01:05:51,979
interpose on because
we're already

1455
01:05:51,979 --> 01:05:54,060
in the trap handler
and something

1456
01:05:54,060 --> 01:05:55,700
else must have triggered

1457
01:05:55,700 --> 01:05:57,339
the trap handler in
the first place,

1458
01:05:57,339 --> 01:05:58,579
and it cannot be this thing

1459
01:05:58,579 --> 01:06:01,120
because this is the
clock algorithm.

1460
01:06:01,120 --> 01:06:05,399
So this is clock. What else do

1461
01:06:05,399 --> 01:06:07,399
we have in this finite
state automaton

1462
01:06:07,399 --> 01:06:09,180
in this state
transition diagram?

1463
01:06:09,180 --> 01:06:14,659
Yes. We have a
transition 0-1, right?

1464
01:06:14,659 --> 01:06:18,319
And this is the transition
we can interpose on.

1465
01:06:21,870 --> 01:06:25,349
This is what we want to be
able to achieve, right?

1466
01:06:25,349 --> 01:06:27,249
If axis bit is set to zero,

1467
01:06:27,249 --> 01:06:29,329
we need to have a way of

1468
01:06:29,329 --> 01:06:32,409
setting the access
variable to one.

1469
01:06:32,409 --> 01:06:35,049
And the only
mechanism we have in

1470
01:06:35,049 --> 01:06:37,689
this system is one
bit, the present bit.

1471
01:06:37,689 --> 01:06:39,849
And so the solution
to this, guys,

1472
01:06:39,849 --> 01:06:41,970
is to basically just mirror

1473
01:06:41,970 --> 01:06:44,889
the state of access
with the present bit.

1474
01:06:44,889 --> 01:06:48,130
So if your PTP mirrors access,

1475
01:06:48,130 --> 01:06:50,369
in other ways, in other words,

1476
01:06:50,369 --> 01:06:51,729
if it's set to zero here,

1477
01:06:51,729 --> 01:06:53,049
you're going to take a trap.

1478
01:06:53,049 --> 01:06:54,810
And then on the trap handler,

1479
01:06:54,810 --> 01:06:56,489
you will update the axis to

1480
01:06:56,489 --> 01:06:59,329
one and you will set
your PTEP to one.

1481
01:06:59,329 --> 01:07:02,010
Okay? So that's the solution.

1482
01:07:02,010 --> 01:07:03,690
That's how you do
it in this system.

1483
01:07:03,690 --> 01:07:06,690
And the way to get to the
solution is by reasoning

1484
01:07:06,690 --> 01:07:08,549
through the finite
state automaton

1485
01:07:08,549 --> 01:07:10,335
for the access variable.

1486
01:07:10,335 --> 01:07:13,000
Because you know that this
is not the mechanism.

1487
01:07:13,000 --> 01:07:14,240
You know that this mechanism

1488
01:07:14,240 --> 01:07:15,980
is already done by the clock,

1489
01:07:15,980 --> 01:07:18,520
and it's already running
on a trap handler

1490
01:07:18,520 --> 01:07:21,480
that somehow was triggered
using another mechanism.

1491
01:07:21,480 --> 01:07:23,260
So the only possible solution

1492
01:07:23,260 --> 01:07:25,979
is this mechanism. And
how do we achieve this?

1493
01:07:25,979 --> 01:07:28,959
Transition between state
zero and state one,

1494
01:07:28,959 --> 01:07:31,480
we can achieve this by making

1495
01:07:31,480 --> 01:07:35,120
our PTP mirror the
accessed variable.

1496
01:07:35,120 --> 01:07:36,459
So if it's set to zero,

1497
01:07:36,459 --> 01:07:39,759
we take a trap and on the
trap handler, we transition.

1498
01:07:39,759 --> 01:07:43,040
So this is a trap handler.

1499
01:07:43,650 --> 01:07:47,609
We transition 0-1 and set

1500
01:07:47,609 --> 01:07:52,749
the axis variable to one
and set PTP to one. Yes.

1501
01:07:52,749 --> 01:07:57,150
Does this mean every time you
invoke a clock algorithm,

1502
01:07:57,150 --> 01:08:00,610
use a page sets the
page to not be present.

1503
01:08:00,610 --> 01:08:03,069
In this system, the only thing,

1504
01:08:03,069 --> 01:08:05,309
the only entity in

1505
01:08:05,309 --> 01:08:07,009
our universe that sets it back

1506
01:08:07,009 --> 01:08:09,210
to zero is the clock algorithm.

1507
01:08:09,210 --> 01:08:11,729
Nobody else sets it to zero.

1508
01:08:11,729 --> 01:08:14,409
That means that it
will only be set to

1509
01:08:14,409 --> 01:08:17,289
zero as often as the
clock algorithm runs.

1510
01:08:17,289 --> 01:08:20,609
If you don't run out of
memory, it will never run.

1511
01:08:20,609 --> 01:08:22,969
I will always be set to one.

1512
01:08:24,490 --> 01:08:27,669
Yes. Now, whenever there's an

1513
01:08:27,669 --> 01:08:30,169
interrupt caused by a
page not being present,

1514
01:08:30,169 --> 01:08:32,689
how do we know that this

1515
01:08:32,689 --> 01:08:33,969
is because our present bit

1516
01:08:33,969 --> 01:08:35,269
is simply mirroring
the access bit,

1517
01:08:35,269 --> 01:08:37,349
and we should just set the
present bit and move on.

1518
01:08:37,349 --> 01:08:39,689
How do you know we should do
that, or if it's actually

1519
01:08:39,689 --> 01:08:40,869
some malicious thing where

1520
01:08:40,869 --> 01:08:42,229
we're actually trying
to access memory,

1521
01:08:42,229 --> 01:08:43,529
which hasn't been allocated yet,

1522
01:08:43,529 --> 01:08:45,509
and we should kill the process.

1523
01:08:45,509 --> 01:08:48,879
Well, for that, you hold the
metadata per frame, right?

1524
01:08:48,879 --> 01:08:51,809
So basically, if you
already hold some logical.

1525
01:08:51,809 --> 01:08:53,909
So for example,
this excess state

1526
01:08:53,909 --> 01:08:55,509
is not a bit in this system.

1527
01:08:55,509 --> 01:08:57,069
It's metadata in your data

1528
01:08:57,069 --> 01:08:58,809
structure that you
are keeping track of.

1529
01:08:58,809 --> 01:09:00,750
And so that's how you
would differentiate

1530
01:09:00,750 --> 01:09:02,729
between those two use cases.

1531
01:09:02,729 --> 01:09:06,269
Between a use case where
your frame already exists,

1532
01:09:06,269 --> 01:09:08,069
and you trapped on it
because that's part of

1533
01:09:08,069 --> 01:09:10,529
your kind of inefficient
design, right,

1534
01:09:10,529 --> 01:09:13,469
to implement the clock
algorithm in this architecture,

1535
01:09:13,469 --> 01:09:14,809
or if it doesn't exist,

1536
01:09:14,809 --> 01:09:16,769
we'll know that it
doesn't exist because

1537
01:09:16,769 --> 01:09:18,909
the data structure
will simply not exist

1538
01:09:18,909 --> 01:09:21,189
for that physical
frame. Make sense?

1539
01:09:21,189 --> 01:09:22,109
Dine.

1540
01:09:22,109 --> 01:09:26,269
Excellent question.
Okay. So I think I

1541
01:09:26,269 --> 01:09:31,739
covered this. You guys
want to keep going.

1542
01:09:31,739 --> 01:09:35,100
So you see how it's 308,

1543
01:09:35,100 --> 01:09:36,679
and we covered only
four questions.

1544
01:09:36,679 --> 01:09:38,739
So I would expect, you know,

1545
01:09:38,739 --> 01:09:40,859
roughly that amount of time

1546
01:09:40,859 --> 01:09:43,879
and that amount of material
to be on the midterm.

1547
01:09:43,879 --> 01:09:45,779
In 50 minutes,
you'll probably be

1548
01:09:45,779 --> 01:09:48,339
given something like
what we've just covered.

1549
01:09:48,339 --> 01:09:54,039
Four questions. Lack of

1550
01:09:54,039 --> 01:09:56,239
write tracking and
write permission bits

1551
01:09:56,239 --> 01:09:58,179
in paging system affect

1552
01:09:58,179 --> 01:10:00,059
the efficiency of
the clock algorithm.

1553
01:10:00,059 --> 01:10:02,699
Please explain why this
inefficiency exists.

1554
01:10:02,699 --> 01:10:05,859
So basically, this is a much
simpler question, right?

1555
01:10:05,859 --> 01:10:08,239
This was the hard question
because it requires you

1556
01:10:08,239 --> 01:10:10,819
to think harder. This is
a much simpler question.

1557
01:10:10,819 --> 01:10:12,419
We only get present bit,

1558
01:10:12,419 --> 01:10:14,759
we don't get read
write or accessed.

1559
01:10:14,759 --> 01:10:16,100
So we cannot differentiate

1560
01:10:16,100 --> 01:10:17,559
between reads and
writes. Can we?

1561
01:10:17,559 --> 01:10:20,379
Yes or no? The
answer is no, right?

1562
01:10:20,379 --> 01:10:22,740
And so if we cannot
differentiate,

1563
01:10:22,740 --> 01:10:24,599
what's the most
conservative assumption

1564
01:10:24,599 --> 01:10:26,679
you can make in this system?

1565
01:10:28,720 --> 01:10:30,719
That's right.

1566
01:10:30,719 --> 01:10:33,359
That any excess is right, right?

1567
01:10:33,359 --> 01:10:35,219
And so what are the
implications of that?

1568
01:10:35,219 --> 01:10:36,740
Because you cannot
differentiate.

1569
01:10:36,740 --> 01:10:38,440
And if you cannot differentiate,

1570
01:10:38,440 --> 01:10:41,259
you have to make the most
conservative assumption.

1571
01:10:41,259 --> 01:10:43,459
That's the thinking part, right?

1572
01:10:43,459 --> 01:10:44,619
That's where kind you have

1573
01:10:44,619 --> 01:10:46,019
to think a little
bit out of the box.

1574
01:10:46,019 --> 01:10:51,919
Yeah. Oh, but you

1575
01:10:51,919 --> 01:10:53,679
need to figure out if

1576
01:10:53,679 --> 01:10:56,004
you need to swap
something out to disc.

1577
01:10:56,004 --> 01:10:57,169
Oh, right?

1578
01:10:57,169 --> 01:11:00,749
And so if you have the
information if it's dirty or not,

1579
01:11:00,749 --> 01:11:02,209
if it's not dirty,
you don't need

1580
01:11:02,209 --> 01:11:03,709
to swap it to disc, right?

1581
01:11:03,709 --> 01:11:05,589
You just unmap it and you map

1582
01:11:05,589 --> 01:11:09,469
in the new frame because
it wasn't dirty.

1583
01:11:09,469 --> 01:11:11,929
But in this particular case,

1584
01:11:11,929 --> 01:11:13,129
kind of since we don't have

1585
01:11:13,129 --> 01:11:15,109
the ability to do
write tracking,

1586
01:11:15,109 --> 01:11:18,829
we cannot keep track of
dirty state on frames.

1587
01:11:18,829 --> 01:11:21,149
We have to make the most
conservative assumption,

1588
01:11:21,149 --> 01:11:23,629
and the most conservative
assumption is that

1589
01:11:23,629 --> 01:11:28,629
any frame that we want to
evict has been written to.

1590
01:11:28,629 --> 01:11:30,229
That's the most
conservative assumption.

1591
01:11:30,229 --> 01:11:31,329
So every single time you

1592
01:11:31,329 --> 01:11:32,869
evict something,
you need to write.

1593
01:11:32,869 --> 01:11:34,329
So that's the implication of

1594
01:11:34,329 --> 01:11:36,689
this assumption. Makes sense?

1595
01:11:38,330 --> 01:11:43,169
Yeah, so I wrote it here
kind of if A is set to one,

1596
01:11:43,169 --> 01:11:45,149
we have to assume that the

1597
01:11:45,149 --> 01:11:48,049
non existent write
bit was set to one.

1598
01:11:48,049 --> 01:11:50,189
That's the assumption
we have to make.

1599
01:11:50,189 --> 01:11:51,809
The implications, you have to

1600
01:11:51,809 --> 01:11:55,009
swap it because you don't
know if it was written to.

1601
01:11:55,410 --> 01:11:58,589
Okay, finally, question six.

1602
01:11:58,589 --> 01:12:01,889
Your friend Robin has written
some clever code to make

1603
01:12:01,889 --> 01:12:03,849
Singleton initialization
code more

1604
01:12:03,849 --> 01:12:06,249
efficient, and this is the code.

1605
01:12:09,250 --> 01:12:12,789
And I think the
question was asking,

1606
01:12:12,789 --> 01:12:15,389
basically, what's
wrong with the code?

1607
01:12:15,389 --> 01:12:18,649
Yeah, what's wrong with
the code, if anything?

1608
01:12:19,570 --> 01:12:21,949
And so, see, some
of you will see

1609
01:12:21,949 --> 01:12:24,189
it right away, like you, right?

1610
01:12:24,189 --> 01:12:26,809
Some of you may not
necessarily see it right

1611
01:12:26,809 --> 01:12:28,109
away because you don't really

1612
01:12:28,109 --> 01:12:29,689
know exactly what
the code is doing.

1613
01:12:29,689 --> 01:12:31,089
You're trying to read the code,

1614
01:12:31,089 --> 01:12:33,269
right, and understand
what it's doing.

1615
01:12:33,269 --> 01:12:36,189
So here's kind of how to
approach this problem.

1616
01:12:36,189 --> 01:12:38,629
I'm kind of trying to give
you this mental framework.

1617
01:12:38,629 --> 01:12:40,849
How do you approach these
problems in general?

1618
01:12:40,849 --> 01:12:42,509
If you're completely lost,

1619
01:12:42,509 --> 01:12:43,969
if you don't know
where to start,

1620
01:12:43,969 --> 01:12:45,709
here's the way to start, right?

1621
01:12:45,709 --> 01:12:47,169
So first of all, you need to

1622
01:12:47,169 --> 01:12:50,169
understand what is this
code trying to do?

1623
01:12:50,169 --> 01:12:53,450
It talks about singleton
initialization.

1624
01:12:53,450 --> 01:12:56,369
Does everyone know
what a Singleton is?

1625
01:12:56,840 --> 01:13:01,599
From 13 31. I'm hoping.

1626
01:13:01,599 --> 01:13:03,439
No.

1627
01:13:08,480 --> 01:13:11,139
And once you know
what Singleton is,

1628
01:13:11,139 --> 01:13:12,379
you'll immediately
know what this

1629
01:13:12,379 --> 01:13:14,599
code is supposed to be doing.

1630
01:13:18,480 --> 01:13:22,019
It's basically the kind
of class of which there

1631
01:13:22,019 --> 01:13:25,814
can only be at
most one instance.

1632
01:13:25,814 --> 01:13:29,529
That's the definition of
a singleton class, okay?

1633
01:13:29,529 --> 01:13:31,329
And so if that is the case,

1634
01:13:31,329 --> 01:13:33,469
kind of when someone is trying

1635
01:13:33,469 --> 01:13:37,209
to allocate an object
of a singleton class,

1636
01:13:37,209 --> 01:13:39,849
your constructor needs to
do something like this.

1637
01:13:39,849 --> 01:13:41,689
Like your constructor needs to

1638
01:13:41,689 --> 01:13:44,169
see or let's not even
call it the constructor.

1639
01:13:44,169 --> 01:13:46,909
I don't want to bring in object
oriented stuff into this.

1640
01:13:46,909 --> 01:13:50,089
Basically, your code
needs to verify whether

1641
01:13:50,089 --> 01:13:50,909
or not you've already

1642
01:13:50,909 --> 01:13:52,649
allocated an instance
of this class,

1643
01:13:52,649 --> 01:13:54,209
right? Yes or no.

1644
01:13:54,209 --> 01:13:55,809
And so that's what kind of

1645
01:13:55,809 --> 01:13:58,669
this if condition is
attempting to figure out.

1646
01:13:58,669 --> 01:14:01,904
If the shared variable P

1647
01:14:01,904 --> 01:14:04,740
so the way the singleton
was implemented

1648
01:14:04,740 --> 01:14:06,179
internally to the class is that

1649
01:14:06,179 --> 01:14:08,079
there's a variable P that kind

1650
01:14:08,079 --> 01:14:09,239
of holds a pointer to the

1651
01:14:09,239 --> 01:14:11,739
allocated object on
the heap, right?

1652
01:14:11,739 --> 01:14:13,359
And if it was not allocated,

1653
01:14:13,359 --> 01:14:15,859
we want to allow the
allocation of this to proceed.

1654
01:14:15,859 --> 01:14:17,399
If it has been allocated,

1655
01:14:17,399 --> 01:14:19,739
we want to disallow the
allocation to proceed.

1656
01:14:19,739 --> 01:14:22,359
So that's the high level
idea behind this code.

1657
01:14:22,359 --> 01:14:25,519
So now that you know
what it's trying to do,

1658
01:14:25,519 --> 01:14:27,339
what is the next step, right?

1659
01:14:27,339 --> 01:14:28,979
So we've defined a singleton.

1660
01:14:28,979 --> 01:14:30,699
Once you have a high level idea,

1661
01:14:30,699 --> 01:14:33,109
identify the critical
shared variable.

1662
01:14:33,109 --> 01:14:36,099
So take a step by
step approach to

1663
01:14:36,099 --> 01:14:39,039
these very complicated
concurrency questions,

1664
01:14:39,039 --> 01:14:41,580
and they are always
going to be complicated.

1665
01:14:41,580 --> 01:14:44,119
But there is a specific way
that you can approach them.

1666
01:14:44,119 --> 01:14:45,919
Understand what the
code is trying to do.

1667
01:14:45,919 --> 01:14:48,259
Figure out what is the
critical shared resource?

1668
01:14:48,259 --> 01:14:51,739
What's the critical shared
resource here? P, right?

1669
01:14:51,739 --> 01:14:53,779
So now that you figured out P,

1670
01:14:53,779 --> 01:14:56,379
kind of squint at the code.

1671
01:14:56,379 --> 01:14:58,559
Forget about all the details

1672
01:14:58,559 --> 01:15:01,159
and find all the reads
and writes to P,

1673
01:15:01,159 --> 01:15:02,859
because that's what matters

1674
01:15:02,859 --> 01:15:04,939
from the concurrency
perspective.

1675
01:15:04,939 --> 01:15:06,779
So what are we doing here?

1676
01:15:06,779 --> 01:15:09,909
We're trying to do a we're

1677
01:15:09,909 --> 01:15:12,289
trying to do a read here on
the shared variable, right?

1678
01:15:12,289 --> 01:15:13,729
And then we grab a lock

1679
01:15:13,729 --> 01:15:15,269
and then we're trying
to do another read,

1680
01:15:15,269 --> 01:15:17,529
and then we're trying
to do a write.

1681
01:15:17,529 --> 01:15:21,969
So we have a read, and then
inside the lock acquired,

1682
01:15:21,969 --> 01:15:24,729
we have another read
and another write.

1683
01:15:26,610 --> 01:15:30,169
Now, can we say if there's
a problem with this code?

1684
01:15:30,169 --> 01:15:38,829
Yeah. Before. Sorry, before

1685
01:15:38,829 --> 01:15:42,090
you acquire lock initialized.

1686
01:15:47,570 --> 01:15:50,869
Yeah, there is a
chance. Yeah, exactly.

1687
01:15:50,869 --> 01:15:52,329
There is a chance
that before you

1688
01:15:52,329 --> 01:15:54,590
acquire lock P is initialized.

1689
01:15:54,590 --> 01:15:57,849
But even higher level than this,

1690
01:15:58,370 --> 01:16:03,069
there's a dumber
solution to this,

1691
01:16:03,069 --> 01:16:04,969
a dumber answer that directly

1692
01:16:04,969 --> 01:16:07,109
follows from the
lecture that I had.

1693
01:16:07,109 --> 01:16:10,749
In the first if statement P can

1694
01:16:10,749 --> 01:16:14,249
be if P has a value
that's not zero,

1695
01:16:14,249 --> 01:16:16,009
then we skip the rest,

1696
01:16:16,009 --> 01:16:22,204
but then it might become
ten but never mind.

1697
01:16:22,204 --> 01:16:24,979
Well, you're trying to
figure out why it's clever.

1698
01:16:24,979 --> 01:16:26,959
That's sort of a separate
bonus question is

1699
01:16:26,959 --> 01:16:29,519
why does Robin think that
this is clever code?

1700
01:16:29,519 --> 01:16:32,179
Actually, can someone
give me venture guess

1701
01:16:32,179 --> 01:16:33,579
of why do we think
that this code

1702
01:16:33,579 --> 01:16:34,719
is clever in the first place?

1703
01:16:34,719 --> 01:16:36,594
Like, why would I write
something like that?

1704
01:16:36,594 --> 01:16:38,869
Yeah, probably you don't

1705
01:16:38,869 --> 01:16:40,629
have to lock if you
already know that

1706
01:16:40,629 --> 01:16:42,009
it's initial or that it's been

1707
01:16:42,009 --> 01:16:44,769
initial he's trying to
alight the locking, right?

1708
01:16:44,769 --> 01:16:46,729
Because locking is
usually expensive.

1709
01:16:46,729 --> 01:16:50,269
And so Robin is trying
to say, Oh, you know,

1710
01:16:50,269 --> 01:16:52,429
I'm only going to lock if

1711
01:16:52,429 --> 01:16:54,489
I feel that I need
to allocate, right?

1712
01:16:54,489 --> 01:16:57,229
So I'm just going to throw in
an IF statement over there,

1713
01:16:57,229 --> 01:16:59,489
and it's going to
check if it's now,

1714
01:16:59,489 --> 01:17:01,849
then I'm going to grab
the lock and actually

1715
01:17:01,849 --> 01:17:04,949
perform another check,
which is very nice.

1716
01:17:04,949 --> 01:17:06,749
He is performing another check

1717
01:17:06,749 --> 01:17:08,849
with this second
If clause, right?

1718
01:17:08,849 --> 01:17:10,409
And then I'm going to allocate.

1719
01:17:10,409 --> 01:17:12,550
So it seems bulletproof.

1720
01:17:13,090 --> 01:17:15,489
Seems bulletproof to me.

1721
01:17:15,489 --> 01:17:18,389
Don't try to find the way in
which it breaks because you

1722
01:17:18,389 --> 01:17:23,649
won't the reason for

1723
01:17:23,649 --> 01:17:25,389
this has to do with
what we went through in

1724
01:17:25,389 --> 01:17:26,709
that lecture where I showed you

1725
01:17:26,709 --> 01:17:29,329
the impossible assembly code.

1726
01:17:30,970 --> 01:17:34,750
Because you are always assuming
sequential consistency.

1727
01:17:34,750 --> 01:17:36,529
Now, should you be assuming

1728
01:17:36,529 --> 01:17:39,569
sequential consistency
in this case?

1729
01:17:43,050 --> 01:17:46,449
Should you be
assuming yes or no?

1730
01:17:46,449 --> 01:17:49,029
Under what conditions can

1731
01:17:49,029 --> 01:17:52,210
we ever assume
sequential consistency?

1732
01:18:02,140 --> 01:18:08,939
This is a good question.
What is the RF zero?

1733
01:18:09,740 --> 01:18:13,139
What is the RF zero, guys?

1734
01:18:16,640 --> 01:18:20,399
Yes. It's the
programming convention,

1735
01:18:20,399 --> 01:18:21,939
that you have to follow to

1736
01:18:21,939 --> 01:18:24,279
ensure that there's no data as.

1737
01:18:25,000 --> 01:18:28,739
No, the first part is correct.

1738
01:18:28,739 --> 01:18:30,339
It's a programming convention,

1739
01:18:30,339 --> 01:18:32,319
but the second part
is not correct.

1740
01:18:32,319 --> 01:18:35,020
It's not going to ensure that
you don't have databases.

1741
01:18:35,020 --> 01:18:37,099
What a DRF zero guarantee tells

1742
01:18:37,099 --> 01:18:40,019
you is that your
code will behave in

1743
01:18:40,019 --> 01:18:43,619
a sequentially consistent
manner if and only

1744
01:18:43,619 --> 01:18:48,619
if you do not have any
databases in the code.

1745
01:18:48,619 --> 01:18:53,440
And everything here is
mathematical, define database.

1746
01:18:54,720 --> 01:19:01,419
Yes. I don't have a Okay,

1747
01:19:01,419 --> 01:19:02,699
can somebody define data?

1748
01:19:02,699 --> 01:19:04,619
I'm asking for a
definition of database.

1749
01:19:04,619 --> 01:19:06,979
Anyone. Definition of data ray.

1750
01:19:06,979 --> 01:19:09,079
You have to know this. Yes.

1751
01:19:11,090 --> 01:19:13,289
Same thing.

1752
01:19:13,289 --> 01:19:16,329
Yeah, you basically
if you ever have

1753
01:19:16,329 --> 01:19:18,029
two unordered accesses to

1754
01:19:18,029 --> 01:19:20,529
the same shared
resource or variable,

1755
01:19:20,529 --> 01:19:22,629
at least one of
which is a right.

1756
01:19:22,629 --> 01:19:24,469
Now, if we have two threads

1757
01:19:24,469 --> 01:19:26,609
executing this, do
we have a problem?

1758
01:19:26,609 --> 01:19:28,849
Do we have two
unordered accesses to

1759
01:19:28,849 --> 01:19:31,810
shared resource which
we have now identified?

1760
01:19:31,810 --> 01:19:33,469
At least one of
which is the right.

1761
01:19:33,469 --> 01:19:37,449
Do we have that? That's
it. You're done.

1762
01:19:37,449 --> 01:19:39,629
And you don't even
have to figure out

1763
01:19:39,629 --> 01:19:42,329
the interleaving for
which it doesn't work.

1764
01:19:42,530 --> 01:19:45,509
Because you won't be able to.

1765
01:19:45,509 --> 01:19:47,649
Interleaving that doesn't work

1766
01:19:47,649 --> 01:19:50,069
actually requires
reordering these things,

1767
01:19:50,069 --> 01:19:51,989
and it can be reordered.

1768
01:19:51,989 --> 01:19:54,830
Because there's no
data flow dependency

1769
01:19:54,830 --> 01:19:57,849
between the P
axises, the read P,

1770
01:19:57,849 --> 01:20:00,409
and then the second read P,
and then another write P,

1771
01:20:00,409 --> 01:20:02,610
not data flow dependencies,

1772
01:20:02,610 --> 01:20:05,629
so we can actually do
anything can happen.

1773
01:20:05,629 --> 01:20:07,369
You have a database, you're

1774
01:20:07,369 --> 01:20:09,649
giving the compiler
a carte blanche,

1775
01:20:09,649 --> 01:20:11,949
right, to do whatever
the hell they want,

1776
01:20:11,949 --> 01:20:13,629
and either the compiler

1777
01:20:13,629 --> 01:20:15,309
or the out of order
processor will

1778
01:20:15,309 --> 01:20:18,569
be able to reorder them
where the unchecked,

1779
01:20:18,569 --> 01:20:20,729
the unordered if condition
at the very top can

1780
01:20:20,729 --> 01:20:23,269
happen in any order relative
to the critical section.

1781
01:20:23,269 --> 01:20:24,529
So here's the truth.

1782
01:20:24,529 --> 01:20:26,329
You cannot assume
that it's going to

1783
01:20:26,329 --> 01:20:28,609
run in sequentially
consistent manner.

1784
01:20:28,609 --> 01:20:33,024
You have violated the
DRF zero guarantee. Yes.

1785
01:20:33,024 --> 01:20:36,499
Possibly not relevant. But would

1786
01:20:36,499 --> 01:20:38,439
there not be a data
dependency between

1787
01:20:38,439 --> 01:20:40,759
the second statement
and the malloc

1788
01:20:40,759 --> 01:20:42,259
because the P would

1789
01:20:42,259 --> 01:20:45,119
change as result of
the malloc assignment?

1790
01:20:47,920 --> 01:20:51,419
The first read is

1791
01:20:51,419 --> 01:20:52,959
a read and then the second write

1792
01:20:52,959 --> 01:20:54,339
doesn't depend on that read.

1793
01:20:54,339 --> 01:20:56,039
Because you see that malloc

1794
01:20:56,039 --> 01:20:57,719
doesn't take P as a parameter.

1795
01:20:57,719 --> 01:21:00,619
It overrides P and the
compiler will detect that.

1796
01:21:00,619 --> 01:21:02,319
The compiler will see that P

1797
01:21:02,319 --> 01:21:04,619
is actually just
being overwritten.

1798
01:21:04,619 --> 01:21:07,299
Right? And so,

1799
01:21:07,299 --> 01:21:08,859
but let's assume even if

1800
01:21:08,859 --> 01:21:10,619
there is a dependency
between those two,

1801
01:21:10,619 --> 01:21:12,859
but it's not going to be
a data flow dependency,

1802
01:21:12,859 --> 01:21:16,079
it's going to be a control
flow dependency, okay?

1803
01:21:16,079 --> 01:21:17,939
Because it's a jump not

1804
01:21:17,939 --> 01:21:20,239
equal or jump not zero
or something like that,

1805
01:21:20,239 --> 01:21:22,359
there's going to be a
control flow dependency that

1806
01:21:22,359 --> 01:21:24,799
will ensure that order,
and that's fine.

1807
01:21:24,799 --> 01:21:26,459
But it's still not
going to ensure

1808
01:21:26,459 --> 01:21:28,979
the order with the
first if statement.

1809
01:21:28,979 --> 01:21:31,039
And that can be
reordered relative to

1810
01:21:31,039 --> 01:21:33,119
the second one in any way,

1811
01:21:33,119 --> 01:21:34,559
shape, or form
because you do have

1812
01:21:34,559 --> 01:21:37,419
a database here in
the school. Okay?

1813
01:21:37,419 --> 01:21:42,344
So this is one of my most
favorite questions to ask.

1814
01:21:42,344 --> 01:21:44,769
So determine if
there's a data base,

1815
01:21:44,769 --> 01:21:45,829
that's sort of the final thing.

1816
01:21:45,829 --> 01:21:47,689
And then remember, DRF zero,

1817
01:21:47,689 --> 01:21:50,189
if you don't have DRF
zero, all bets are off.

1818
01:21:50,189 --> 01:21:53,329
Anything can happen. You
have undefined behavior.

1819
01:21:53,329 --> 01:21:54,949
And so, you know,

1820
01:21:54,949 --> 01:21:57,389
I provided here where
you can actually fail.

1821
01:21:57,389 --> 01:22:00,849
But basically, think about

1822
01:22:00,849 --> 01:22:03,669
the second part of the
question is asking,

1823
01:22:03,669 --> 01:22:05,849
how would you fix the code?

1824
01:22:05,849 --> 01:22:07,849
So now it's sort of once you've

1825
01:22:07,849 --> 01:22:10,189
done this critical
analysis of the code,

1826
01:22:10,189 --> 01:22:12,349
and first of all,
you understand why

1827
01:22:12,349 --> 01:22:14,949
Robin thinks it's clever, right?

1828
01:22:14,949 --> 01:22:16,829
It really is clever, right?

1829
01:22:16,829 --> 01:22:18,029
Because Robin is making

1830
01:22:18,029 --> 01:22:20,530
the assumption of
sequential consistency.

1831
01:22:20,530 --> 01:22:24,589
And he would avoid, he
would elide locking with

1832
01:22:24,589 --> 01:22:26,429
this code if we actually

1833
01:22:26,429 --> 01:22:29,349
lived in a world where
databases don't exist, right?

1834
01:22:29,349 --> 01:22:31,409
But they do exist in this code.

1835
01:22:31,409 --> 01:22:32,749
And so, how would you fix that?

1836
01:22:32,749 --> 01:22:34,849
What's the way to fix this code?

1837
01:22:34,849 --> 01:22:37,149
I can see people
shaking their head,

1838
01:22:37,149 --> 01:22:39,609
like, You're breaking
my universe, man.

1839
01:22:39,609 --> 01:22:43,379
It's I love doing that.

1840
01:22:43,379 --> 01:22:47,399
Yeah. Huh?

1841
01:22:47,399 --> 01:22:51,419
Yeah, you get rid of the
outer statement, right?

1842
01:22:51,419 --> 01:22:54,959
Have you affected the
correctness of the code?

1843
01:22:54,959 --> 01:22:57,260
You got rid of the cleverness,

1844
01:22:57,260 --> 01:22:59,499
which was buggy, right?

1845
01:22:59,499 --> 01:23:02,899
But you actually made the
code correct because now

1846
01:23:02,899 --> 01:23:07,059
you've ordered accesses
to the shared variable.

1847
01:23:08,140 --> 01:23:11,639
And that's it.
Thank you so much.

1848
01:23:11,639 --> 01:23:14,179
See you on Tuesday.
